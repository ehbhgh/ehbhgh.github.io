<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Ajax学习</title>
      <link href="/2020/07/22/Ajax%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/07/22/Ajax%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Ajax学习"><a href="#Ajax学习" class="headerlink" title="Ajax学习"></a>Ajax学习</h1><h2 id="1-什么是ajax"><a href="#1-什么是ajax" class="headerlink" title="1.什么是ajax"></a>1.什么是ajax</h2><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200718145530847.png" alt="image-20200718145530847"></p><p><strong>它是浏览器提供的一套方法，可以实现页面无刷新更新数据，提高用户浏览网站应用的体验</strong></p><h2 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2.应用场景"></a>2.应用场景</h2><p><strong>1.页面上拉加载更多数据</strong></p><p><strong>2.列表数据无刷新分页</strong></p><p><strong>3.表单项离开焦点数据验证</strong></p><p><strong>4.搜索框提示文字下拉列表</strong></p><h2 id="3-运行原理"><a href="#3-运行原理" class="headerlink" title="3.运行原理"></a>3.运行原理</h2><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200718150708492.png" alt="image-20200718150708492"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200719125804899.png" alt="image-20200719125804899"></p><h2 id="4使用步骤"><a href="#4使用步骤" class="headerlink" title="4使用步骤"></a>4使用步骤</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1.创建Ajax对象</span><br><span class="line"></span><br><span class="line">let xhr&#x3D;new XMLHttpquest()</span><br><span class="line"></span><br><span class="line">2.告诉Ajax请求地址以及请求方式</span><br><span class="line"></span><br><span class="line">shr.open(&quot;get&#x2F;post&quot;,&quot;http:&#x2F;&#x2F;www.exmaple.com实际上就是服务器上路由请求地址&quot;)</span><br><span class="line"></span><br><span class="line">3.发送请求</span><br><span class="line"></span><br><span class="line">xhr.send()</span><br><span class="line"></span><br><span class="line">4.获取服务器端给客户端的响应数据</span><br><span class="line"></span><br><span class="line">xhr.onload&#x3D;function()&#123;</span><br><span class="line"></span><br><span class="line">console.log(xhr.responseText)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200719133318540.png" alt="image-20200719133318540"></p><h2 id="5-web服务器"><a href="#5-web服务器" class="headerlink" title="5.web服务器"></a>5.web服务器</h2><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200718154022671.png" alt="image-20200718154022671"></p><h2 id="6-ajax使用过程"><a href="#6-ajax使用过程" class="headerlink" title="6.ajax使用过程"></a>6.ajax使用过程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"> &lt;select name&#x3D;&quot;&quot; id&#x3D;&quot;selt&quot;&gt;</span><br><span class="line"></span><br><span class="line">​    &lt;option value&#x3D;&quot;&quot;&gt;全部&lt;&#x2F;option&gt;</span><br><span class="line"></span><br><span class="line">  &lt;&#x2F;select&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line"></span><br><span class="line">​    window.onload &#x3D; function () &#123;</span><br><span class="line"></span><br><span class="line">​      const selt &#x3D; document.getElementById(&quot;selt&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​      &#x2F;&#x2F;创建XMLHttpRequest请求对象</span><br><span class="line"></span><br><span class="line">​      let xhr &#x3D; new XMLHttpRequest()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​      &#x2F;&#x2F;打开服务器连接，设置请求方式</span><br><span class="line"></span><br><span class="line">​      xhr.open(&quot;GET&quot;, &quot;http:&#x2F;&#x2F;139.9.209.237&#x2F;herowebapi&#x2F;power&#x2F;list&quot;, true)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​      &#x2F;&#x2F;监听请求过程</span><br><span class="line"></span><br><span class="line">​      xhr.onreadystatechange &#x3D; function () &#123;</span><br><span class="line"></span><br><span class="line">​        if (this.readyState &#x3D;&#x3D; 4 &amp;&amp; this.status &#x3D;&#x3D; 200) &#123;</span><br><span class="line"></span><br><span class="line">​          let res &#x3D; JSON.parse(this.responseText)</span><br><span class="line"></span><br><span class="line">​          if (res.Code &#x3D;&#x3D; 100) &#123;</span><br><span class="line"></span><br><span class="line">​            let datas &#x3D; res.Data</span><br><span class="line"></span><br><span class="line">​            console.log(datas)</span><br><span class="line"></span><br><span class="line">​            for (let i &#x3D; 0; i &lt; datas.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">​              let option &#x3D; document.createElement(&quot;option&quot;)</span><br><span class="line"></span><br><span class="line">​              console.log(this.Name)</span><br><span class="line"></span><br><span class="line">​              option.innerHTML &#x3D; datas[i].Name</span><br><span class="line"></span><br><span class="line">​              option.value &#x3D; datas[i].Id</span><br><span class="line"></span><br><span class="line">​              selt.appendChild(option)</span><br><span class="line"></span><br><span class="line">​            &#125;</span><br><span class="line"></span><br><span class="line">​          &#125;</span><br><span class="line"></span><br><span class="line">​          else &#123;</span><br><span class="line"></span><br><span class="line">​            console.log(&quot;请求失败&quot; + res.message)</span><br><span class="line"></span><br><span class="line">​          &#125;</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​      &#x2F;&#x2F;发送请求</span><br><span class="line"></span><br><span class="line">​      xhr.send()</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200719132501637.png" alt="image-20200719132501637"></p><h2 id="7-无参数的get请求"><a href="#7-无参数的get请求" class="headerlink" title="7.无参数的get请求"></a>7.无参数的get请求</h2><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200719134140356.png" alt="image-20200719134140356"></p><h2 id="8-有参数的get请求"><a href="#8-有参数的get请求" class="headerlink" title="8.有参数的get请求"></a>8.有参数的get请求</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line">  &lt;select name&#x3D;&quot;&quot; id&#x3D;&quot;selt&quot;&gt;</span><br><span class="line"></span><br><span class="line">​    &lt;option value&#x3D;&quot;11&quot;&gt;国家&lt;&#x2F;option&gt;</span><br><span class="line"></span><br><span class="line">  &lt;&#x2F;select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;table&gt;</span><br><span class="line"></span><br><span class="line">​    &lt;thead&gt;</span><br><span class="line"></span><br><span class="line">​      &lt;tr&gt;</span><br><span class="line"></span><br><span class="line">​        &lt;th&gt;ID&lt;&#x2F;th&gt;</span><br><span class="line"></span><br><span class="line">​        &lt;th&gt;Name&lt;&#x2F;th&gt;</span><br><span class="line"></span><br><span class="line">​        &lt;th&gt;Adress&lt;&#x2F;th&gt;</span><br><span class="line"></span><br><span class="line">​      &lt;&#x2F;tr&gt;</span><br><span class="line"></span><br><span class="line">​    &lt;&#x2F;thead&gt;</span><br><span class="line"></span><br><span class="line">​    &lt;tbody&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​    &lt;&#x2F;tbody&gt;</span><br><span class="line"></span><br><span class="line">  &lt;&#x2F;table&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line"></span><br><span class="line">​    let tb &#x3D; document.querySelector(&quot;tbody&quot;)</span><br><span class="line"></span><br><span class="line">​    let selt &#x3D; document.getElementById(&quot;selt&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​    &#x2F;&#x2F;下拉列表改变函数</span><br><span class="line"></span><br><span class="line">​    function change()&#123;</span><br><span class="line"></span><br><span class="line">​       &#x2F;&#x2F;创建XMLHttpRequest请求对象</span><br><span class="line"></span><br><span class="line">​    let xhr1 &#x3D; new XMLHttpRequest()</span><br><span class="line"></span><br><span class="line">​    &#x2F;&#x2F;打开服务器连接，设置请求方式</span><br><span class="line"></span><br><span class="line">​    xhr1.open(&quot;GET&quot;, &quot;http:&#x2F;&#x2F;139.9.209.237&#x2F;herowebapi&#x2F;power&#x2F;list&quot;, true)</span><br><span class="line"></span><br><span class="line">​    &#x2F;&#x2F;监听请求过程</span><br><span class="line"></span><br><span class="line">​    xhr1.onreadystatechange &#x3D; function () &#123;</span><br><span class="line"></span><br><span class="line">​      if (this.readyState &#x3D;&#x3D; 4 &amp;&amp; this.status &#x3D;&#x3D; 200) &#123;</span><br><span class="line"></span><br><span class="line">​        let res &#x3D; JSON.parse(this.responseText)</span><br><span class="line"></span><br><span class="line">​        if (res.Code &#x3D;&#x3D; 100) &#123;</span><br><span class="line"></span><br><span class="line">​          let datas &#x3D; res.Data</span><br><span class="line"></span><br><span class="line">​          console.log(datas)</span><br><span class="line"></span><br><span class="line">​          for (let i &#x3D; 0; i &lt; datas.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">​            let option &#x3D; document.createElement(&quot;option&quot;)</span><br><span class="line"></span><br><span class="line">​            option.innerHTML &#x3D; datas[i].Name</span><br><span class="line"></span><br><span class="line">​            option.value &#x3D; datas[i].Id</span><br><span class="line"></span><br><span class="line">​            selt.appendChild(option)</span><br><span class="line"></span><br><span class="line">​            selt.onchange &#x3D; function () &#123;</span><br><span class="line"></span><br><span class="line">​              tb.innerHTML &#x3D; &quot;&quot;&#x2F;&#x2F;清空上一次表格添加</span><br><span class="line"></span><br><span class="line">​              index &#x3D; this.value&#x2F;&#x2F;将index变成动态的index可选项</span><br><span class="line"></span><br><span class="line">​              ready()&#x2F;&#x2F;根据对应的index动态的添加</span><br><span class="line"></span><br><span class="line">​            &#125;</span><br><span class="line"></span><br><span class="line">​          &#125;</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​        else &#123;</span><br><span class="line"></span><br><span class="line">​          console.log(&quot;请求失败&quot; + res.message)</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​    xhr1.send()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    &#x2F;&#x2F;表格改变函数</span><br><span class="line"></span><br><span class="line">​    function ready() &#123;</span><br><span class="line"></span><br><span class="line">​      let xhr &#x3D; new XMLHttpRequest()</span><br><span class="line"></span><br><span class="line">​      xhr.open(&quot;get&quot;, &#96;http:&#x2F;&#x2F;139.9.209.237&#x2F;herowebapi&#x2F;hero&#x2F;list?powerId&#x3D;$&#123;index&#125;&#96;, true);</span><br><span class="line"></span><br><span class="line">​      xhr.onreadystatechange &#x3D; function () &#123;</span><br><span class="line"></span><br><span class="line">​        if (this.readyState &#x3D;&#x3D; 4 &amp;&amp; this.status &#x3D;&#x3D; 200) &#123;</span><br><span class="line"></span><br><span class="line">​          let res &#x3D; JSON.parse(this.responseText)</span><br><span class="line"></span><br><span class="line">​          if (res.Code &#x3D;&#x3D; 100) &#123;</span><br><span class="line"></span><br><span class="line">​            let datas &#x3D; res.Data</span><br><span class="line"></span><br><span class="line">​            console.log(datas)</span><br><span class="line"></span><br><span class="line">​            for (let i &#x3D; 0; i &lt; datas.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">​              &#x2F;&#x2F;创建表格</span><br><span class="line"></span><br><span class="line">​              let tr &#x3D; document.createElement(&quot;tr&quot;)</span><br><span class="line"></span><br><span class="line">​              for (let key in datas[i]) &#123;</span><br><span class="line"></span><br><span class="line">​                let td &#x3D; document.createElement(&quot;td&quot;)</span><br><span class="line"></span><br><span class="line">​                if (typeof datas[i][key] !&#x3D; &quot;object&quot;) &#123;&#x2F;&#x2F;判断类型根据类型筛选</span><br><span class="line"></span><br><span class="line">​                  td.innerHTML &#x3D; datas[i][key]</span><br><span class="line"></span><br><span class="line">​                  tr.appendChild(td)</span><br><span class="line"></span><br><span class="line">​                &#125;</span><br><span class="line"></span><br><span class="line">​              &#125;</span><br><span class="line"></span><br><span class="line">​              tb.appendChild(tr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​            &#125;</span><br><span class="line"></span><br><span class="line">​          &#125;</span><br><span class="line"></span><br><span class="line">​          else &#123;</span><br><span class="line"></span><br><span class="line">​            console.log(&quot;请求失败&quot; + res.Message)</span><br><span class="line"></span><br><span class="line">​          &#125;</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line">​      xhr.send()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   window.onload&#x3D;function()&#123;</span><br><span class="line"></span><br><span class="line">​     change()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h2 id="9-post请求"><a href="#9-post请求" class="headerlink" title="9.post请求"></a>9.post请求</h2><p>1.打开连接后要设置请求头</p><p> <strong>xhr.setRequestHeader(“Content-Type”,”application/x-www-form-urlencoded”)</strong></p><p>2.将参数放入send方法内，格式为<strong>key=value&amp;&amp;key=value</strong></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200719155838423.png" alt="image-20200719155838423"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200719155913528.png" alt="image-20200719155913528"></p><h2 id="10-Ajax注册"><a href="#10-Ajax注册" class="headerlink" title="10.Ajax注册"></a>10.Ajax注册</h2><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200719162209434.png" alt="image-20200719162209434"></p><h2 id="11-Ajax登录"><a href="#11-Ajax登录" class="headerlink" title="11.Ajax登录"></a>11.Ajax登录</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>组件</title>
      <link href="/2020/07/22/%E7%BB%84%E4%BB%B6/"/>
      <url>/2020/07/22/%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="一-父子组件通信结合双向绑定"><a href="#一-父子组件通信结合双向绑定" class="headerlink" title="一.父子组件通信结合双向绑定"></a>一.父子组件通信结合双向绑定</h2><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200630192708118.png" alt="image-20200630192708118"></p><h4 id="父组件"><a href="#父组件" class="headerlink" title="父组件"></a><strong>父组件</strong></h4><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200630192857340.png" alt="image-20200630192857340"></p><h4 id="子组件"><a href="#子组件" class="headerlink" title="子组件"></a><strong>子组件</strong></h4><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200630192806826.png" alt="image-20200630192806826"></p><h2 id="二-父子组件访问方式"><a href="#二-父子组件访问方式" class="headerlink" title="二.父子组件访问方式"></a>二.父子组件访问方式</h2><p><strong>在父组件中拿到子组件的对象，子组件有一方法，父组件可直接调用</strong></p><h4 id="1-父访问子"><a href="#1-父访问子" class="headerlink" title="1.父访问子"></a>1.父访问子</h4><p><strong>利用this.$children（此时拿到的是一个数组)或者利用this.$refs(此种方式首先要在标签中定义一个ref属性，例如：ref=”aa”,并且此种方式获取的是一个对象)</strong></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200630203819357.png" alt="image-20200630203819357"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200630203845567.png" alt="image-20200630203845567"></p><h4 id="2-子访问父"><a href="#2-子访问父" class="headerlink" title="2.子访问父"></a><strong>2.子访问父</strong></h4><p><strong>*利用this.$parent可以使子组件访问父组件，利用this.$root可以使子组件访问根组件</strong></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200630211718407.png" alt="image-20200630211718407"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200630212245770.png" alt="image-20200630212245770"></p><h2 id="三-插槽的使用"><a href="#三-插槽的使用" class="headerlink" title="三.插槽的使用"></a>三.插槽的使用</h2><h4 id="插槽简介"><a href="#插槽简介" class="headerlink" title="插槽简介"></a>插槽简介</h4><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200630234102223.png" alt="image-20200630234102223"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200630234124779.png" alt="image-20200630234124779"></p><h4 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h4><p><strong>有多个插槽，指定插槽修改默认值，所以需要给插槽定义名字，此时，修改插槽值默认值将不会改变，只可以修改没有名字的插槽默认值。</strong></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200701000436837.png" alt="image-20200701000436837"></p><h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4><p><strong>此时的V-show在的作用域为VUE实例，所以vue实例中的flag控制它的显示隐藏状态</strong></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200701091031299.png" alt="image-20200701091031299"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200701091057654.png" alt="image-20200701091057654"></p><h4 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h4><p><strong>父组件替换插槽的标签，但是内容由子组件来提供</strong></p><p>我们先提一个需求：</p><p>子组件中包括一组数据，比如：pLanguages: [‘JavaScript’, ‘Python’, ‘Swift’, ‘Go’, ‘C++’]，需要在多个界面进行展示：</p><p>1.某些界面是以水平方向一一展示的，</p><p>2.某些界面是以列表形式展示的，</p><p>3.某些界面直接展示一个数组</p><p>内容在子组件，希望父组件告诉我们如何展示，怎么办呢？利用slot作用域插槽就可以了</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200701110820090.png" alt="image-20200701110820090"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>配置对象</title>
      <link href="/2020/07/22/%E9%85%8D%E7%BD%AE%E5%AF%B9%E8%B1%A1/"/>
      <url>/2020/07/22/%E9%85%8D%E7%BD%AE%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p><strong>配置对象</strong></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200714154605545.png" alt="image-20200714154605545"></p><p><strong>es6默认导出，仅有一个</strong></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200714155911816.png" alt="image-20200714155911816"></p><p><strong>es6具名导出</strong></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200714160050446.png" alt="image-20200714160050446"></p><p><strong>es6导入默认</strong><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200714161230215.png" alt="image-20200714161230215"></p><p><strong>导入全部</strong></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200714161454238.png" alt="image-20200714161454238"></p><p><strong>es6只会缓存一次</strong></p><p><strong>组件概念</strong></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200714161747656.png" alt="image-20200714161747656"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200714162000145.png" alt="image-20200714162000145"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>模块化</title>
      <link href="/2020/07/22/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
      <url>/2020/07/22/%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="模块化开发"><a href="#模块化开发" class="headerlink" title="模块化开发"></a>模块化开发</h1><p>模块化开发中在Javacript标签中引入type=”module”解决命名冲突问题</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702103525156.png" alt="image-20200702103525156"></p><h2 id="1-模块导入导出"><a href="#1-模块导入导出" class="headerlink" title="1.模块导入导出"></a>1.模块导入导出</h2><h3 id="1-导出方式1"><a href="#1-导出方式1" class="headerlink" title="1.导出方式1"></a>1.导出方式1</h3><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702100608148.png" alt="image-20200702100608148"></p><h3 id="1-导入方式1"><a href="#1-导入方式1" class="headerlink" title="1.导入方式1"></a>1.导入方式1</h3><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702100644224.png" alt="image-20200702100644224"></p><h3 id="2-导出方式2"><a href="#2-导出方式2" class="headerlink" title="2.导出方式2"></a>2.导出方式2</h3><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702101301405.png" alt="image-20200702101301405"></p><h3 id="2-导入方式2"><a href="#2-导入方式2" class="headerlink" title="2.导入方式2"></a>2.导入方式2</h3><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702101349889.png" alt="image-20200702101349889"></p><h3 id="3-导出函数和类"><a href="#3-导出函数和类" class="headerlink" title="3.导出函数和类"></a>3.导出函数和类</h3><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702102354583.png" alt="image-20200702102354583"></p><h3 id="4-默认导出"><a href="#4-默认导出" class="headerlink" title="4.默认导出"></a>4.默认导出</h3><p><strong>只能有一个，是固定死的，不允许存在多个，导入时会默认去找那个import且导入时不需要与导出的变量名相同不需要用{}了</strong></p><h6 id=""><a href="#" class="headerlink" title=""></a><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702103238800.png" alt="image-20200702103238800"></h6><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702103254779.png" alt="image-20200702103254779"></p><h2 id="2-webpack"><a href="#2-webpack" class="headerlink" title="2.webpack"></a>2.webpack</h2><h3 id="1-初步了解"><a href="#1-初步了解" class="headerlink" title="1.初步了解"></a>1.初步了解</h3><p>是一种模块化打包工具（模块化和打包），可以将一些模块化（commonjs,es6）转化为浏览器可以识别的语法格式，处理模块间的依赖关系</p><p>webpack中两个文件夹（dist）：一般表示打包后的源码，用于最终的开发运用，（src）：表示开发源码文件夹，在src中建立main.js文件。</p><p>导出common JS</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702182621914.png" alt="image-20200702182621914"></p><p>导入common JS</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702182903099.png" alt="image-20200702182903099"></p><p>安装检测成功：输入webpack –version 出现版本号（全局安装）</p><p>打包成功</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702114548941.png" alt="image-20200702114548941"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702114033961.png" alt="image-20200702114033961"></p><h3 id="2-配置webpack"><a href="#2-配置webpack" class="headerlink" title="2.配置webpack"></a>2.配置webpack</h3><p><strong>webpack.config.js的配置</strong></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702194754915.png" alt="image-20200702194754915"></p><p><strong>命令映射webpack===&gt;npm run build</strong></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702194206976.png" alt="image-20200702194206976"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702194714601.png" alt="image-20200702194714601"></p><p>全局webpack与本地webpack</p><p>本地与项目相匹配</p><p>开发时依赖    webpack（打包过程有用，之后无用）</p><p>运行时依赖   </p><p><strong>本地安装webpack:</strong>npm install <a href="mailto:webpack@3.6.0">webpack@3.6.0</a>(版本号) –save-dev</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702195648246.png" alt="image-20200702195648246"></p><p><strong>只要在终端敲命令都是全局的webpack</strong></p><p><strong>命令映射webpack===&gt;npm run build</strong>；<strong>定义脚本这个过程可以使用本地的webpack</strong>;<strong>在packagejson中的script中定义一个属性build（或者其他）属性值定义为webpack(或者其他，如果文件，名很长还需要在webpack后面指定它的名字），因此做一个映射。</strong></p><h3 id="3-webpack配置css"><a href="#3-webpack配置css" class="headerlink" title="3.webpack配置css"></a>3.webpack配置css</h3><p><strong>通过loader转换webpack使其支持不同的文件类型</strong></p><p>步骤一：通过npm安装loader</p><p>步骤二：在webpack.config.js中的module关键字下面进行配置</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702202914789.png" alt="image-20200702202914789"></p><p><strong>安装css依赖</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev css-loader</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702203533840.png" alt="image-20200702203533840"></p><p><strong>在webpack.config.js中的module.export中加入</strong></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702203710909.png" alt="image-20200702203710909"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702204212564.png" alt="image-20200702204212564"></p><p><strong>css-lodel只负责加载不负责渲染，只安装它不报错但是页面也没有效果</strong></p><p><strong>安装style依赖</strong></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702205124753.png" alt="image-20200702205124753"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702205029339.png" alt="image-20200702205029339"></p><h3 id="4-webpack配置less"><a href="#4-webpack配置less" class="headerlink" title="4.webpack配置less"></a>4.webpack配置less</h3><p>装对应得包对less文件进行转化</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702210408851.png" alt="image-20200702210408851"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702211030123.png" alt="image-20200702211030123"></p><h3 id="5-weakpack配置Vue"><a href="#5-weakpack配置Vue" class="headerlink" title="5.weakpack配置Vue"></a>5.weakpack配置Vue</h3><p>1.前提是先配置webpack,写一个webpack.config.js文件，在安装vue,输入命令npm install vue –save</p><p>2.在入口js文件中导入vue</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200704100258848.png" alt="image-20200704100258848"></p><p>3.在html文件中写入vue的模块</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200704100315467.png" alt="image-20200704100315467"></p><p>4.(1).runtime-only  代码中不可以有任何模块（2）.runtime-compiler代码中，可以有template,因为有compiler可以用来编译template</p><p>会默认以runtime-only的方式去编译，因为vue自身是一个模块，因此直接设置会报错。</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200704100731838.png" alt="image-20200704100731838"></p><p>5.需要指定它的配置,通过在webpack.config.js中去配置一个resolve属性，通过vue别名找到对应的vue版本</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200704101725667.png" alt="image-20200704101725667"></p><p>6.可以将<div id="app"><div>中的数据提取出来，在外面用一个模板template,el中定义的id会去找template，并将<div id="app"><div>替换成对应的template模板中的数据</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200704142529454.png" alt="image-20200704142529454"></p><p>7.可以将所有关于app组件封装到一个文件中，用export  default默认导出，import from导入</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200704150306913.png" alt="image-20200704150306913"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200704150329601.png" alt="image-20200704150329601"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200704151156116.png" alt="image-20200704151156116"></p><h3 id="6抽离组件"><a href="#6抽离组件" class="headerlink" title="6抽离组件"></a>6抽离组件</h3><p>将原本比较复杂的exportdefault中的对象抽离出去</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200704153900751.png" alt="image-20200704153900751"></p><p><strong>上述条件无法使vue文件运行，需要配置vue的loade</strong></p><h3 id="7配置vue的loade"><a href="#7配置vue的loade" class="headerlink" title="7配置vue的loade"></a>7配置vue的loade</h3><h4 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h4><p>输入命令：<strong>npm install vue-loader vue-template-compiler –save-dev</strong> </p><p><strong>vue loade的加载和编译</strong></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200704154457728.png" alt="image-20200704154457728"></p><h4 id="2-配置"><a href="#2-配置" class="headerlink" title="2.配置"></a>2.配置</h4><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200704161211717.png" alt="image-20200704161211717"></p><h3 id="8-vue-cli-脚手架"><a href="#8-vue-cli-脚手架" class="headerlink" title=" 8.vue cli(脚手架)"></a><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200704163558098.png" alt="image-20200704163558098"> 8.vue cli(脚手架)</h3><p>自动配置开发所需要的环境</p><p><strong>脚手架3的全局安装</strong></p><p>npm install -g @vue/cli</p><p><strong>如果需要用到脚手架2则需要在脚手架3的基础上安装一个模块</strong></p><p>npm install @vue/cli-init -g</p><p><strong>脚手架2初始化项目</strong></p><p>vue init webpack my-project（项目名称）</p><p><strong>脚手架3初始化项目</strong></p><p>vue create my-project</p><h4 id="1-脚手架2初始化项目"><a href="#1-脚手架2初始化项目" class="headerlink" title="1.脚手架2初始化项目"></a>1.脚手架2初始化项目</h4><p>vue init webpack my-project（项目名称）    </p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200712154539428.png" alt="image-20200712154539428"></p><h4 id="2-vue-li2的目录结构"><a href="#2-vue-li2的目录结构" class="headerlink" title="2.vue li2的目录结构"></a>2.vue li2的目录结构</h4><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200712162751515.png" alt="image-20200712162751515"></p><h3 id="9vue的程序运行过程"><a href="#9vue的程序运行过程" class="headerlink" title="9vue的程序运行过程"></a>9vue的程序运行过程</h3><h4 id="1-runtimeonly"><a href="#1-runtimeonly" class="headerlink" title="1.runtimeonly"></a><strong>1.runtimeonly</strong></h4><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200713183736021.png" alt="image-20200713183736021"></p><p><strong>render(functions)——-&gt;virtual dom(虚拟dom)——&gt;ui，性能更高，代码更少</strong></p><h4 id="2-runtimecompiler"><a href="#2-runtimecompiler" class="headerlink" title="2.runtimecompiler"></a><strong>2.runtimecompiler</strong></h4><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200713183831785.png" alt="image-20200713183831785"></p><p><strong>template——–&gt;解析成ast（抽象语法树）——&gt;render(functions)——-&gt;virtual dom(虚拟dom)——&gt;ui</strong></p><p>由于runtimecompiler比runtimeonly多了template解析ast和编译成render函数，所以也多了6kb内存</p><h4 id="3-render函数"><a href="#3-render函数" class="headerlink" title="3.render函数"></a><strong>3.render函数</strong></h4><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200713191359518.png" alt="image-20200713191359518"></p><h3 id="10-vuecli3"><a href="#10-vuecli3" class="headerlink" title="10.vuecli3"></a><strong>10.vuecli3</strong></h3><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200713194118422.png" alt="image-20200713194118422"></p><p> <strong>“@vue/cli-service”: “~4.4.0”,把包隐藏了</strong></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200713194728797.png" alt="image-20200713194728797"></p><h4 id="1-脚手架3目录结构"><a href="#1-脚手架3目录结构" class="headerlink" title="1.脚手架3目录结构"></a><strong>1.脚手架3目录结构</strong></h4><p><strong>初始化脚手架3：vue create my-project</strong></p><p><strong>配置脚手架3</strong></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200713195039790.png" alt="image-20200713195039790"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200720183936446.png" alt="image-20200720183936446"></p><p>**<img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200720184043361.png" alt="image-20200720184043361"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200720184436828.png" alt="image-20200720184436828"></p><p>**<img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200720184610076.png" alt="image-20200720184610076"></p><p><strong>项目文件</strong>:<strong>npm run serve</strong></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200713195343770.png" alt="image-20200713195343770"></p><h2 id="3vue路由router"><a href="#3vue路由router" class="headerlink" title="3vue路由router"></a>3vue路由router</h2><p>路由提供两种机制：路由和转送</p><p>路由是决定数据包从来源到目的地的路径</p><p>传送将输入端的数据转移到合适的输出端。</p><p>路由映射，每台电脑都有一个mac地址（唯一的）,把内网Ip和mac地址一一对应。</p><p>信息通过网络将信息通过公网Ip发出，到路由器。路由器需要对收集到的信息再一次转发。</p><p><strong>路由映射表：决定数据包指向</strong></p><h3 id="1-前端渲染，后端渲染"><a href="#1-前端渲染，后端渲染" class="headerlink" title="1.前端渲染，后端渲染"></a>1.前端渲染，后端渲染</h3><p>1.后端渲染</p><p>jsp/php/c#</p><p>jsp:Java写让浏览器展示</p><p>html+css+js</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200713205705814.png" alt="image-20200713205705814"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200713212308998.png" alt="image-20200713212308998"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200713214128497.png" alt="image-20200713214128497"></p><h3 id="2-url的hash与HTML5的history"><a href="#2-url的hash与HTML5的history" class="headerlink" title="2.url的hash与HTML5的history"></a>2.url的hash与HTML5的history</h3><h4 id="1-利用location-hash改变"><a href="#1-利用location-hash改变" class="headerlink" title="1.利用location.hash改变"></a><strong>1.利用location.hash改变</strong></h4><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200720200047076.png" alt="image-20200720200047076"></p><h4 id="2-HTML5的history"><a href="#2-HTML5的history" class="headerlink" title="2.HTML5的history"></a>2.HTML5的history</h4><p><strong>history.pushState()</strong></p><p><strong>返回，入栈</strong></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200720200311792.png" alt="image-20200720200311792"></p><p><strong>history.back()</strong></p><p><strong>返回，出栈</strong></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200720200649896.png" alt="image-20200720200649896"></p><p><strong>hostory.replaceState()</strong></p><p><strong>无法返回</strong></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200720200900672.png" alt="image-20200720200900672"></p><p><strong>go()</strong></p><p><strong>hostory.go(-1)=hostory.back()</strong></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200720201119848.png" alt="image-20200720201119848"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vue路由</title>
      <link href="/2020/07/22/vue%E8%B7%AF%E7%94%B1/"/>
      <url>/2020/07/22/vue%E8%B7%AF%E7%94%B1/</url>
      
        <content type="html"><![CDATA[<h2 id="1-vue路由"><a href="#1-vue路由" class="headerlink" title="1.vue路由"></a>1.vue路由</h2><p>安装vue-router</p><p>npm install vue-router –save</p><p><strong>配置路由文件</strong></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200714191434803.png" alt="image-20200714191434803"></p><p>导入路由文件，挂载到Vue实例上去</p><ol><li><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200714191556442.png" alt="image-20200714191556442"></li></ol><h2 id="2-路由映射关系"><a href="#2-路由映射关系" class="headerlink" title="2.路由映射关系"></a>2.路由映射关系</h2><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200714195410383.png" alt="image-20200714195410383"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200714195434666.png" alt="image-20200714195434666"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200714195659401.png" alt="image-20200714195659401"></p><h2 id="router-link上的属性"><a href="#router-link上的属性" class="headerlink" title="router-link上的属性"></a>router-link上的属性</h2><p><strong>router-link上有一个to属性用于改变地址，还有一个tag属性可以将默认的转化成的a标签换成其他标签。</strong></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200714224005440.png" alt="image-20200714224005440"></p><p><strong>replace属性不会留下history记录</strong></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200714224355272.png" alt="image-20200714224355272"></p><h2 id="通过代码实现路由跳转"><a href="#通过代码实现路由跳转" class="headerlink" title="通过代码实现路由跳转"></a><strong>通过代码实现路由跳转</strong></h2><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200714231141651.png" alt="image-20200714231141651"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200714231154969.png" alt="image-20200714231154969"></p><h2 id="动态路由的使用"><a href="#动态路由的使用" class="headerlink" title="动态路由的使用"></a>动态路由的使用</h2><p><strong>1首先配置组件</strong></p><p><strong>2.配置组件路由</strong></p><p><strong>3.将组件路由换成动态绑定</strong></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200715153345550.png" alt="image-20200715153345550"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200715153516717.png" alt="image-20200715153516717"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200715200953870.png" alt="image-20200715200953870"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200715180604563.png" alt="image-20200715180604563"></p><h2 id="路由的懒加载"><a href="#路由的懒加载" class="headerlink" title="路由的懒加载"></a>路由的懒加载</h2><p><strong>先打包 npm run build</strong></p><hr><p>当打包时，由于项目过大，打包中的js会越来越大，希望一个路由打包一个js文件</p><p>懒加载：用到时候在加载</p><p>把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应的组件，这样就更加搞笑了</p><p>向静态服务器请求的时间过长，因为js文件过大,所以需要单独的从服务器请求当个的组件数据，进行单个JS进行打包</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200715190558134.png" alt="image-20200715190558134"></p><h2 id="路由的嵌套"><a href="#路由的嵌套" class="headerlink" title="路由的嵌套"></a>路由的嵌套</h2><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200715190732592.png" alt="image-20200715190732592"></p><p>1.创建对应的子组件，并且在路由映射中配置对应的子路由</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200715193915222.png" alt="image-20200715193915222"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200715194059333.png" alt="image-20200715194059333"></p><p>2.在组件内部使用<router-view>标签</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200715194326951.png" alt="image-20200715194326951"></p><h2 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h2><p>最开始渲染的是APP.vue,它是整个程序的入口</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200715194943371.png" alt="image-20200715194943371"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200715195129784.png" alt="image-20200715195129784"></p><p>1.首先创建一个profile组件，用$route.query获取路由配置的参数对象</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200715203818677.png" alt="image-20200715203818677"></p><p>2.配置组件</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200715203941294.png" alt="image-20200715203941294"></p><p>3路由懒加载和组件引入</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200715204002087.png" alt="image-20200715204002087"></p><p>4.在app.vue中配置路由和要传递的参数</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200715204149812.png" alt="image-20200715204149812"></p><p><strong>通过button标签的方式</strong></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200715205438362.png" alt="image-20200715205438362"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200715205502547.png" alt="image-20200715205502547"></p><h2 id="vue运行后自动打开网页"><a href="#vue运行后自动打开网页" class="headerlink" title="vue运行后自动打开网页"></a>vue运行后自动打开网页</h2><p>需要在与src同级配置一个vue.config.js文件</p><p>module.exports = {</p><p>  devServer: {</p><p>  open: true,</p><p>  disableHostCheck: false,</p><p>  host: “0.0.0.0”,</p><p>  port: 8099,</p><p>  https: false,</p><p>  hotOnly: false, </p><p>  proxy: null </p><p>  }</p><p>  };</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200715202205872.png" alt="image-20200715202205872"></p><h2 id="router与-route的区别"><a href="#router与-route的区别" class="headerlink" title="$router与$route的区别"></a>$router与$route的区别</h2><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200715210708575.png" alt="image-20200715210708575"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200715210900002.png" alt="image-20200715210900002"></p><p><strong>以上打印router相同</strong></p><p><strong>this.$router表示创建的路由对象</strong></p><p><strong>this.$route表示活跃路由对象</strong></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200715212830286.png" alt="image-20200715212830286"></p><p><strong>所有的组件的继承Vue的原型</strong></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200715224557463.png" alt="image-20200715224557463"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200715224629521.png" alt="image-20200715224629521"></p><h2 id="全局导航守卫"><a href="#全局导航守卫" class="headerlink" title="全局导航守卫"></a>全局导航守卫</h2><p>生命周期created函数是组件创建后回调</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200715225040412.png" alt="image-20200715225040412"></p><p>将template挂载到虚拟dom树上</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200715225151221.png" alt="image-20200715225151221"></p><p>界面发生更新</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200715230827447.png" alt="image-20200715230827447"></p><p><strong>导航守卫就是监听从哪里跳转到哪里</strong></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200715234259050.png" alt="image-20200715234259050"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200715234457791.png" alt="image-20200715234457791"></p><p><strong>配置路由</strong></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200715234523574.png" alt="image-20200715234523574"></p><p><strong>meta表示元数据，一般表示描述数据的数据</strong></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200715235022402.png" alt="image-20200715235022402"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200715235319579.png" alt="image-20200715235319579"></p><p><strong>全局守卫</strong></p><p>befoEach:跳转之前调用前置守卫</p><p>afterEach：跳转完毕后置钩子</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200716000933149.png" alt="image-20200716000933149"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200716001255643.png" alt="image-20200716001255643"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200716001606244.png" alt="image-20200716001606244"></p><h2 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h2><p>它是vue的内置组件，可以使被包含的组件保留状态，或避免重新渲染。</p><p>router-view也是一个组件，如果直接被包在keep-live里面，所有路径匹配到视图组件都会被缓存。</p><keep-alive><router-view/></keep-alive>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vue基础-vue-cli（vue脚手架）</title>
      <link href="/2020/07/22/vue%E5%9F%BA%E7%A1%80-vue-cli%EF%BC%88vue%E8%84%9A%E6%89%8B%E6%9E%B6%EF%BC%89/"/>
      <url>/2020/07/22/vue%E5%9F%BA%E7%A1%80-vue-cli%EF%BC%88vue%E8%84%9A%E6%89%8B%E6%9E%B6%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="2-vue基础-vue-cli（vue脚手架）"><a href="#2-vue基础-vue-cli（vue脚手架）" class="headerlink" title="2. vue基础-vue-cli（vue脚手架）"></a><a href="https://www.cnblogs.com/mapengfei247/p/11074429.html" target="_blank" rel="noopener">2. vue基础-vue-cli（vue脚手架）</a></h2><h2 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a><strong>1. 作用</strong></h2><p> 快速创建一个基于webpack模板的项目</p><h2 id="2-安装工具"><a href="#2-安装工具" class="headerlink" title="2. 安装工具"></a><strong>2. 安装工具</strong></h2><ol><li><strong>安装webpack</strong>：使用npm全局安装<strong>webpack</strong>,打开命令行工具，输入 <code>npm install webpack -g</code>，安装完成之后，输入 <code>webpack -v</code> 即可查看当前安装版本，出现版本号说明安装成功</li><li><strong>全局安装vue-cli：</strong>在命令行输入 <code>npm install --global vue-cli</code>，安装完成之后，输入 <code>vue -V</code>查看当前版本号</li></ol><p><img src= "/img/loading.gif" data-src="https://img2018.cnblogs.com/blog/1569217/201906/1569217-20190623212021752-94610793.png" alt="img"></p><h2 id="3-使用Vue-cli来构建项目"><a href="#3-使用Vue-cli来构建项目" class="headerlink" title="3. 使用Vue-cli来构建项目"></a>3. 使用Vue-cli来构建项目</h2><ol><li><p>新建文件夹Vue，进入文件夹，输入 <code>vue init webpack vue-cli-test</code>，其中vue-cli-test为新项目文件名</p></li><li><p>跳入选择项来进行项目信息填写与确认</p><ul><li>Project name (baoge)： —–项目名称，直接回车，按照括号中默认名字（注意这里的名字不能有大写字母，如果有会报错Sorry, name can no longer contain capital letters），阮一峰老师博客<a href="https://link.jianshu.com/?t=http://www.ruanyifeng.com/blog/2017/02/filename-should-be-lowercase.html" target="_blank" rel="noopener">为什么文件名要小写</a> ，可以参考一下。</li><li>Project description (A Vue.js project)： —-项目描述，也可直接点击回车，使用默认名字</li><li>Author ()： —-作者，输入mapengfei<br>接下来会让用户选择：</li><li>Runtime + Compiler: recommended for most users 运行加编译，既然已经说了推荐，就选它了<br>Runtime-only: about 6KB lighter min+gzip, but templates (or any Vue-specificHTML) are ONLY allowed in .vue files - render functions are required elsewhere 仅运行时，已经有推荐了就选择第一个了</li><li>Install vue-router? (Y/n) 是否安装vue-router，这是官方的路由，大多数情况下都使用，这里就输入“y”后回车即可。</li><li>Use ESLint to lint your code? (Y/n) 是否使用ESLint管理代码，ESLint是个代码风格管理工具，是用来统一代码风格的，一般项目中都会使用。<br>接下来也是选择题Pick an ESLint preset (Use arrow keys) 选择一个ESLint预设，编写vue项目时的代码风格，直接y回车</li><li>Setup unit tests with Karma + Mocha? (Y/n) 是否安装单元测试，选择安装y回车</li><li>Setup e2e tests with Nightwatch(Y/n)? 是否安装e2e测试 ，选择安装y回车</li></ul><p><img src= "/img/loading.gif" data-src="https://img2018.cnblogs.com/blog/1569217/201906/1569217-20190623212059304-930156370.png" alt="img"></p></li><li><p>配置完成之后，Vue目录下面多了一个vue-cli-test的文件夹，进入文件夹，下载依赖 <code>npm install</code></p></li></ol><p><img src= "/img/loading.gif" data-src="https://img2018.cnblogs.com/blog/1569217/201906/1569217-20190623212111978-1829060313.png" alt="img"></p><ol><li><p>修改配置，启动项目</p><ul><li>修改 config里面的index.js文件</li></ul><p><img src= "/img/loading.gif" data-src="https://img2018.cnblogs.com/blog/1569217/201906/1569217-20190623212124481-1681244652.png" alt="img"></p><ul><li>修改端口号是为了防止端口号被占用，修改assetsPublicPath属性是因为打包后，外部引入js和css文件时，如果路径是以<code>&#39;/&#39;</code>开头，在本地是无法找到对应文件的，所以<strong>如果要在本地打开打包后的文件</strong>，就得修改路劲为<code>&#39;/&#39;</code></li><li>输入 <code>npm run dev</code> 启动项目，成功后输入访问地址，显示如下界面</li></ul></li></ol><p><img src= "/img/loading.gif" data-src="https://img2018.cnblogs.com/blog/1569217/201906/1569217-20190623212137324-1834337869.png" alt="img"></p><p><img src= "/img/loading.gif" data-src="https://img2018.cnblogs.com/blog/1569217/201906/1569217-20190623212152029-2118125993.png" alt="img"></p><h2 id="4-项目目录介绍"><a href="#4-项目目录介绍" class="headerlink" title="4. 项目目录介绍"></a>4. 项目目录介绍</h2><p><img src= "/img/loading.gif" data-src="https://img2018.cnblogs.com/blog/1569217/201906/1569217-20190623212204169-1457958325.png" alt="img"></p><p>在 package.json中可以看到开发和生产环境的配置文件入口</p><p><img src= "/img/loading.gif" data-src="https://img2018.cnblogs.com/blog/1569217/201906/1569217-20190623212216721-1353927001.png" alt="img"></p><p><img src= "/img/loading.gif" data-src="https://img2018.cnblogs.com/blog/1569217/201906/1569217-20190623212224710-925553721.png" alt="img"></p><ul><li>可以看到dev中的设置，<strong>build/webpack.dev.conf.js</strong>，该文件是开发环境中webpack的配置入口。</li><li>在webpack.dev.conf.js中出现<strong>webpack.base.conf.js</strong>，这个文件是开发环境和生产环境，甚至测试环境，这些环境的公共webpack配置。可以说，这个文件相当重要。</li></ul><h2 id="5-打包部署"><a href="#5-打包部署" class="headerlink" title="5. 打包部署"></a>5. 打包部署</h2><ul><li>自己开发的项目文件都需要放到src目录下面</li><li>在项目开发完成之后，使用 <code>npm run build</code>来打包项目，打包完成后会生成<strong>dist</strong>文件夹，如果已修改了文件路径，可以直接在本地打开</li><li>项目上线时，直接将<strong>dist</strong>文件夹放到服务器即可</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>v-model双向绑定</title>
      <link href="/2020/07/22/v-model%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/"/>
      <url>/2020/07/22/v-model%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<p>vue学习</p><h1 id="1-v-model-数据双向绑定"><a href="#1-v-model-数据双向绑定" class="headerlink" title="1.v-model 数据双向绑定"></a>1.v-model 数据双向绑定</h1><h2 id="1-v-model修饰符"><a href="#1-v-model修饰符" class="headerlink" title="1.v-model修饰符"></a>1.v-model修饰符</h2><p><img src= "/img/loading.gif" data-src="D:%5C%E4%B8%8B%E8%BD%BD%5CQQ%E5%9B%BE%E7%89%8720200618202201.png" alt=""></p><h2 id="2-v-model中的checkbox"><a href="#2-v-model中的checkbox" class="headerlink" title="2.v-model中的checkbox"></a>2.v-model中的checkbox</h2><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200618202451172.png" alt="image-20200618202451172"></p><h2 id="3-v-model中的select"><a href="#3-v-model中的select" class="headerlink" title="3.v-model中的select"></a>3.v-model中的select</h2><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200618202644485.png" alt="image-20200618202644485"></p><h2 id="4-值绑定"><a href="#4-值绑定" class="headerlink" title="4.值绑定"></a>4.值绑定</h2><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200618202802739.png" alt="image-20200618202802739"></p><h2 id="5-数据的双向绑定原理"><a href="#5-数据的双向绑定原理" class="headerlink" title="5.数据的双向绑定原理"></a>5.数据的双向绑定原理</h2><h3 id="原理：发布订阅加数据劫持"><a href="#原理：发布订阅加数据劫持" class="headerlink" title="原理：发布订阅加数据劫持"></a>原理：发布订阅加数据劫持</h3><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200618203010581.png" alt="image-20200618203010581"></p><h3 id="数据劫持"><a href="#数据劫持" class="headerlink" title="数据劫持"></a>数据劫持</h3><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200618203237190.png" alt="image-20200618203237190"></p><h3 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h3><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200618203551968.png" alt="image-20200618203551968"></p><p>2.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ref的用法</title>
      <link href="/2020/07/22/ref%E7%9A%84%E7%94%A8%E6%B3%95/"/>
      <url>/2020/07/22/ref%E7%9A%84%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>ref 有三种用法：</p><p>　　1、ref 加在普通的元素上，用this.ref.name 获取到的是dom元素</p><p>　　2、ref 加在子组件上，用this.ref.name 获取到的是<strong>组件实例，可以使用组件的所有方法</strong>。</p><p>　　3、如何利用 v-for 和 ref 获取一组数组或者dom 节点</p><p><img src= "/img/loading.gif" data-src="https://images2018.cnblogs.com/blog/1158910/201808/1158910-20180801214649396-707668096.png" alt="img"></p><p><img src= "/img/loading.gif" data-src="https://images2018.cnblogs.com/blog/1158910/201808/1158910-20180801214632214-356594092.png" alt="img"></p><p>　　注意：</p><p>　　1、<strong>ref 需要在dom渲染完成后才会有</strong>，在使用的时候确保dom已经渲染完成。比如在生命周期 <strong>mounted(){} 钩子中调用</strong>，或者<strong>在 this.$nextTick(()=&gt;{}) 中调用</strong>。</p><p>　　2、如果ref 是循环出来的，<strong>有多个重名，那么ref的值会是一个数组</strong> ，此时要拿到单个的ref 只需要循环就可以了。</p><h3 id="一、ref使用在外面的组件上"><a href="#一、ref使用在外面的组件上" class="headerlink" title="一、ref使用在外面的组件上"></a>一、ref使用在外面的组件上</h3><p><a href="javascript:void(0);"><img src= "/img/loading.gif" data-src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;ref-outside-component&quot; v-on:click&#x3D;&quot;consoleRef&quot;&gt;</span><br><span class="line">    &lt;component-father ref&#x3D;&quot;outsideComponentRef&quot;&gt;</span><br><span class="line">    &lt;&#x2F;component-father&gt;</span><br><span class="line">    &lt;p&gt;ref在外面的组件上&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">    var refoutsidecomponentTem&#x3D;&#123;</span><br><span class="line">        template:&quot;&lt;div class&#x3D;&#39;childComp&#39;&gt;&lt;h5&gt;我是子组件&lt;&#x2F;h5&gt;&lt;&#x2F;div&gt;&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">    var refoutsidecomponent&#x3D;new Vue(&#123;</span><br><span class="line">        el:&quot;#ref-outside-component&quot;,</span><br><span class="line">        components:&#123;</span><br><span class="line">            &quot;component-father&quot;:refoutsidecomponentTem</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            consoleRef:function () &#123;</span><br><span class="line">                console.log(this); &#x2F;&#x2F; #ref-outside-component     vue实例</span><br><span class="line">                console.log(this.$refs.outsideComponentRef);  &#x2F;&#x2F; div.childComp vue实例，组件实例</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src= "/img/loading.gif" data-src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="二、ref作用在外面元素上"><a href="#二、ref作用在外面元素上" class="headerlink" title="二、ref作用在外面元素上"></a>二、ref作用在外面元素上</h3><p><a href="javascript:void(0);"><img src= "/img/loading.gif" data-src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;ref在外面的元素上</span><br><span class="line">&lt;div id&#x3D;&quot;ref-outside-dom&quot; v-on:click&#x3D;&quot;consoleRef&quot; &gt;</span><br><span class="line">   &lt;component-father&gt;</span><br><span class="line">   &lt;&#x2F;component-father&gt;</span><br><span class="line">   &lt;p ref&#x3D;&quot;outsideDomRef&quot;&gt;ref在外面的元素上&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">    var refoutsidedomTem&#x3D;&#123;</span><br><span class="line">        template:&quot;&lt;div class&#x3D;&#39;childComp&#39;&gt;&lt;h5&gt;我是子组件&lt;&#x2F;h5&gt;&lt;&#x2F;div&gt;&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">    var refoutsidedom&#x3D;new Vue(&#123;</span><br><span class="line">        el:&quot;#ref-outside-dom&quot;,</span><br><span class="line">        components:&#123;</span><br><span class="line">            &quot;component-father&quot;:refoutsidedomTem</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            consoleRef:function () &#123;</span><br><span class="line">                console.log(this); &#x2F;&#x2F; #ref-outside-dom    vue实例</span><br><span class="line">                console.log(this.$refs.outsideDomRef);  &#x2F;&#x2F;  &lt;p&gt;标签dom元素 ref在外面的元素上&lt;&#x2F;p&gt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src= "/img/loading.gif" data-src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="三、ref使用在里面的元素上–局部注册组件"><a href="#三、ref使用在里面的元素上–局部注册组件" class="headerlink" title="三、ref使用在里面的元素上–局部注册组件"></a>三、ref使用在里面的元素上–局部注册组件</h3><p><a href="javascript:void(0);"><img src= "/img/loading.gif" data-src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;ref在里面的元素上</span><br><span class="line">&lt;div id&#x3D;&quot;ref-inside-dom&quot;&gt;</span><br><span class="line">    &lt;component-father&gt;</span><br><span class="line">    &lt;&#x2F;component-father&gt;</span><br><span class="line">    &lt;p&gt;ref在里面的元素上&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">    var refinsidedomTem&#x3D;&#123;</span><br><span class="line">        template:&quot;&lt;div class&#x3D;&#39;childComp&#39; v-on:click&#x3D;&#39;consoleRef&#39;&gt;&quot; +</span><br><span class="line">                       &quot;&lt;h5 ref&#x3D;&#39;insideDomRef&#39;&gt;我是子组件&lt;&#x2F;h5&gt;&quot; +</span><br><span class="line">                  &quot;&lt;&#x2F;div&gt;&quot;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            consoleRef:function () &#123;</span><br><span class="line">                console.log(this);  &#x2F;&#x2F; div.childComp   vue实例 </span><br><span class="line">                console.log(this.$refs.insideDomRef);  &#x2F;&#x2F; &lt;h5 &gt;我是子组件&lt;&#x2F;h5&gt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    var refinsidedom&#x3D;new Vue(&#123;</span><br><span class="line">        el:&quot;#ref-inside-dom&quot;,</span><br><span class="line">        components:&#123;</span><br><span class="line">            &quot;component-father&quot;:refinsidedomTem</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src= "/img/loading.gif" data-src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h3 id="四、ref使用在里面的元素上–全局注册组件"><a href="#四、ref使用在里面的元素上–全局注册组件" class="headerlink" title="四、ref使用在里面的元素上–全局注册组件"></a>四、ref使用在里面的元素上–全局注册组件</h3><p><a href="javascript:void(0);"><img src= "/img/loading.gif" data-src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;ref在里面的元素上--全局注册</span><br><span class="line">&lt;div id&#x3D;&quot;ref-inside-dom-all&quot;&gt;</span><br><span class="line">    &lt;ref-inside-dom-quanjv&gt;&lt;&#x2F;ref-inside-dom-quanjv&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">    Vue.component(&quot;ref-inside-dom-quanjv&quot;,&#123;</span><br><span class="line">        template:&quot;&lt;div class&#x3D;&#39;insideFather&#39;&gt; &quot; +</span><br><span class="line">                    &quot;&lt;input type&#x3D;&#39;text&#39; ref&#x3D;&#39;insideDomRefAll&#39; v-on:input&#x3D;&#39;showinsideDomRef&#39;&gt;&quot; +</span><br><span class="line">                    &quot;  &lt;p&gt;ref在里面的元素上--全局注册 &lt;&#x2F;p&gt; &quot; +</span><br><span class="line">                  &quot;&lt;&#x2F;div&gt;&quot;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            showinsideDomRef:function () &#123;</span><br><span class="line">                console.log(this); &#x2F;&#x2F;这里的this其实还是div.insideFather</span><br><span class="line">                console.log(this.$refs.insideDomRefAll); &#x2F;&#x2F; &lt;input  type&#x3D;&quot;text&quot;&gt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    var refinsidedomall&#x3D;new Vue(&#123;</span><br><span class="line">        el:&quot;#ref-inside-dom-all&quot;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>编程思想（面向对象与面向过程）</title>
      <link href="/2020/07/22/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8E%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%EF%BC%89/"/>
      <url>/2020/07/22/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8E%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>编程:<br>            面向过程和面向对象.<br>            对象:具体的某个事物,有特性(属性)和行为(方法)  -  万物皆对象<br>            编程:<br>            面向过程和面向对象.<br>            对象:具体的某个事物,有特性(属性)和行为(方法)  -  万物皆对象</p><pre><code>如何创建对象?通过new Object();    字面量{};    自定义构造函数(工厂模式)创建対象的方式:1.调用Object() -- 创建出来的所有的对象都是Object类型的,无法具体的区分.2.字面量{} -- 只能创建一个对象(一次创建一个)3.工厂模式创建对象 -- 目的:自定义构造函数(优化后的工厂模式)自定义构造函数创建对象干了4件事情:1.在内存中申请了一块空闲的空间,为了存储创建的对象2.this表示当前实例化的对象3.设置对象中的属性和方法4.把创建后的对象返回都是通过new的方式实现.什么是原型:为了共享数据和节省内存空间的目的而开辟的一块区域.构造函数中有一个prototype,是原型,程序员使用.是标准的.实例对象中有一个__proto__,是原型,浏览器使用.不是很标准.实例对象中的__proto__指向的是该实例对象的构造函数中的prortype构造函数中的prototype里面的属性和方法,可以通过实例对象来调用.语法:正常的写法:实例对象.__proto__才能够访问到构造函数中的prototype中的属性和方法举例:p.__proto__.eat(); -- __proto__不是一个标准的属性,所以可以 - p.eat();原型就是属性,而这个属性也是一个对象.举例:Person.prototype -- 是一个属性    Person.prototype.属性或者方法 -- Person.prototype是一个对象原型存在的意义:本身在构造函数中定义的属性和方法,当实例化对象的时候,实例化对象中的属性和方法都是在自己的空间中存在的,如果是多个对象,这些属性和方法都会在单独的空间中存在(在各自的实例对象中),浪费了空间的资源,所以为了节省空间资源,把公共的属性和方法放到原型中,达到共享数据的目的.系统中的内置对象可以有原型,并且原型中也可以添加数据格式举例:String.prototype.方法 = 匿名函数var str = &quot;&quot;;str.方法();自调用函数:不需要调用,直接在页面加载结束的时候自动执行作用:有独立的作用域,防止数据污染.沙箱:就是一个虚拟的空间,在这个空间中处理或者是运行代码,与外面无关,不影响到其他的作用域,         在自调用函数中就是一个概念.在自调用函数中,如果外面需要访问到沙箱(自调用函数的作用域)中的数据,那么可以使用window.变量将作用域中的局部变量转换为隐式全局变量,从而可以访问.在沙箱中可以定义私有函数,要去访问私有函数可以通过构造函数中传入this.方法名,之后先调用构造函数(经过暴露的),然后通过构造函数调用私有的方法.</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>this 关键字的用法</title>
      <link href="/2020/07/22/this%20%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%94%A8%E6%B3%95/"/>
      <url>/2020/07/22/this%20%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="重学-this-关键字的用法"><a href="#重学-this-关键字的用法" class="headerlink" title="重学 this 关键字的用法"></a>重学 this 关键字的用法</h2><h2 id="为什么要学习this关键字"><a href="#为什么要学习this关键字" class="headerlink" title="为什么要学习this关键字"></a>为什么要学习this关键字</h2><p>\1. 面试会问啊！总有一些面试官喜欢问你一段不可能这么写的代码。看一道经典且古老的面试题(学完本文后，文末会有一道更复杂的面试题等着你哦！)</p><p>代码如下:</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200629183048633.png" alt="image-20200629183048633"></p><p>\2. 我在读 Events 的 lib/events 源码的时候发现多次用到call关键字，看来有必要搞懂 this 与 call 相关的所有内容。</p><p>其中几句代码是这样写的</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200629183209900.png" alt="image-20200629183209900"></p><p>3.箭头函数使用不当报错，在封装 Node.js 的一个 ORM 映射框架 Sequelize 时，封装表关联关系，由于使用箭头函数造成了读到的上下文发生变化，不是想要的 model 信息，而是指向了全局 。</p><p>\4. call 关键字在写代码过程中还是比较常用的，有时候我们常常会使用 call 关键字来指定某个函数运行时的上下文，有时候还使用 call 关键字实现继承。</p><p>代码例子如下:</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200629183504790.png" alt="image-20200629183504790"></p><h2 id="文章概览图"><a href="#文章概览图" class="headerlink" title="文章概览图"></a>文章概览图</h2><p><img src= "/img/loading.gif" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/YBFV3Da0NwsLYSeGFqp73lHCibfGA144V9fxLVbKw1QsSY8kJYnPEusgxqw2cKvdzUvkjuQ3QjrDPsvABDicx7Kw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>JS（ES5）里面有三种函数调用形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func(p1, p2) obj.child.method(p1, p2)func.call(context, p1, p2) &#x2F;&#x2F; 这里先不讲 apply</span><br></pre></td></tr></table></figure><p>好多初学者都只用到过前两种情况，而且认为前两者优于第三者。直到几天前想系统复习一下this关键字，找this相关的各种资料，在知乎看到了一个关于this的讨论。说第三种形式才是正常的调用形式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func.call(context,p1,p2)</span><br></pre></td></tr></table></figure><p>其它两种都是语法糖，可以等价的变为 <code>call</code>形式。<code>func(p1,p2)等价于func.call(undefined,p1,p2);</code></p><p><code>obj.child.method(p1,p2)等价于obj.child.method.call(obj.child,p1,p2);</code>这么看我们的函数调用只有一种形式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func.call(context,p1,p2)</span><br></pre></td></tr></table></figure><p>这时候是不是就知道this是什么了，就是上面的context。回到我开篇提到的面试题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; 5;let obj &#x3D; &#123;  a : 10,  foo: function()&#123;    console.log(this.a)  &#125;&#125;</span><br><span class="line">let bar &#x3D; obj.fooobj.foo() bar()</span><br></pre></td></tr></table></figure><ul><li>obj.foo() 转化为call的形式就是obj.foo.call(obj)</li></ul><p>所以this指向了obj</p><ul><li>bar() 转化为call的形式就是bar.call() 由于没有传 context，所以 this 就是 undefined，如果是在浏览器中最后给你一个默认的 this——window 对象。如果是在 Node.js 环境中运行 this——globel对象。在浏览器中运行结果为5 在 Node.js 环境中为 undefined。</li></ul><h3 id="Node-js-环境下指向全局的this关键字说明-你可能不知道"><a href="#Node-js-环境下指向全局的this关键字说明-你可能不知道" class="headerlink" title="Node.js 环境下指向全局的this关键字说明(你可能不知道)"></a>Node.js 环境下指向全局的this关键字说明(你可能不知道)</h3><p>为什么在浏览器或者前端环境可以直接正常输出值，而在 Node.js 环境中输出的却是 <code>undefined</code>。看一下这段代码你可能就懂了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(function(exports, require, module, __filename, __dirname) &#123;    &#123;    &#x2F;&#x2F; 模块的代码    &#x2F;&#x2F; 所以那整个代码应该在这里吧    var a &#x3D; 10;    function A()&#123;        a &#x3D; 5;        console.log(a);        console.log(this.a);    &#125;    &#x2F;&#x2F; const haha &#x3D; new A();    A();    &#125;&#125;);</span><br></pre></td></tr></table></figure><p>先说一下 Node.js 环境下在运行某个 js 模块代码时候发生了什么，Node.js 在执行代码之前会使用一个代码封装器进行封装，例如下面所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(function(exports, require, module, __filename, __dirname) &#123;    &#123;    &#x2F;&#x2F; 模块的代码    &#x2F;&#x2F; 所以那整个代码应该在这里吧    &#125;&#125;);</span><br></pre></td></tr></table></figure><p>这段代码在 Node.js 环境下输出结果为 <code>5，undefined</code>是不是就能理解了。这里面的this是默认绑定指向全局，当输出this.a的时候，全局应该指向这个闭包的最外层。所以输出结果式是undefined。</p><h3 id="语法中的this关键字"><a href="#语法中的this关键字" class="headerlink" title="[]语法中的this关键字"></a>[]语法中的this关键字</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function fn ()&#123; console.log(this) &#125;var arr &#x3D; [fn, fn2]arr[0]() &#x2F;&#x2F; 这里面的 this 又是什么呢？</span><br></pre></td></tr></table></figure><p>我们可以把 arr0 想象为arr.0( )，虽然后者的语法错了，但是形式与转换代码里的 obj.child.method(p1, p2) 对应上了，于是就可以愉快的转换了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr[0]() 假想为    arr.0()然后转换为 arr.0.call(arr)那么里面的 this 就是 arr 了</span><br></pre></td></tr></table></figure><h2 id="this绑定原则"><a href="#this绑定原则" class="headerlink" title="this绑定原则"></a>this绑定原则</h2><h3 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h3><p>默认绑定是函数针对的独立调用的时候，不带任何修饰的函数引用进行调用，非严格模式下 this 指向全局对象(浏览器下指向 Window，Node.js 环境是 Global ），严格模式下，this 绑定到 undefined ,严格模式不允许this指向全局对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var  a &#x3D; &#39;hello&#39;</span><br><span class="line">var obj &#x3D; &#123;    a: &#39;koala&#39;,    foo: function() &#123;        console.log(this.a)    &#125;&#125;</span><br><span class="line">var  bar &#x3D; obj.foo</span><br><span class="line">bar()              &#x2F;&#x2F; 浏览器中输出: &quot;hello&quot;</span><br></pre></td></tr></table></figure><p>这段代码， <code>bar()</code>就是默认绑定，函数调用的时候，前面没有任何修饰调用，也可以用之前的 <code>call</code>函数调用形式理解，所以输出结果是 <code>hello</code>。</p><h4 id="默认绑定的另一种情况"><a href="#默认绑定的另一种情况" class="headerlink" title="默认绑定的另一种情况"></a>默认绑定的另一种情况</h4><p>在函数中以函数作为参数传递，例如 <code>setTimeOut</code>和 <code>setInterval</code>等，这些函数中传递的函数中的 <code>this</code>指向，在非严格模式指向的是全局对象。</p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var name &#x3D; &#39;koala&#39;;var person2 &#x3D; &#123;    name: &#39;程序员成长指北&#39;,    sayHi: sayHi&#125;</span><br><span class="line">function sayHi()&#123;    console.log(&#39;Hello,&#39;, this.name);&#125;</span><br><span class="line">setTimeout(function()&#123;    person2.sayHi();&#125;,200);&#x2F;&#x2F; 输出结果 Hello,koala</span><br></pre></td></tr></table></figure><h3 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h3><p>判断 this 隐式绑定的基本标准:函数调用的时候是否在上下文中调用，或者说是否某个对象调用函数。</p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; &#39;koala&#39;</span><br><span class="line">var obj &#x3D; &#123;    a: &#39;程序员成长指北&#39;,    foo: function() &#123;        console.log(this.a)    &#125;&#125;obj.foo()       &#x2F;&#x2F; 浏览器中输出: &quot;程序员成长指北&quot;</span><br></pre></td></tr></table></figure><p>foo 方法是作为对象的属性调用的，那么此时 foo 方法执行时，this 指向 obj 对象。</p><p><strong>隐式绑定的另一种情况</strong></p><p>当有多层对象嵌套调用某个函数的时候，如 <code>对象.对象.函数</code>,this 指向的是最后一层对象。</p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function sayHi()&#123;    console.log(&#39;Hello,&#39;, this.name);&#125;var person2 &#x3D; &#123;    name: &#39;程序员成长指北&#39;,    sayHi: sayHi&#125;var person1 &#x3D; &#123;    name: &#39;koala&#39;,    friend: person2&#125;person1.friend.sayHi();</span><br><span class="line">&#x2F;&#x2F; 输出结果为 Hello, 程序员成长指北</span><br></pre></td></tr></table></figure><p>看完这个例子，是不是也就懂了隐式调用的这种情况。</p><h3 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h3><p>显式绑定，通过函数call apply bind 可以修改函数this的指向。call 与 apply 方法都是挂载在 Function 原型下的方法，所有的函数都能使用。</p><h4 id="call-和-apply-的区别"><a href="#call-和-apply-的区别" class="headerlink" title="call 和 apply 的区别"></a>call 和 apply 的区别</h4><ol><li>call和apply的第一个参数会绑定到函数体的this上，如果 <code>不传参数</code>，例如 <code>fun.call()</code>，非严格模式，this默认还是绑定到全局对象</li><li>call函数接收的是一个参数列表，apply函数接收的是一个参数数组。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unc.call(thisArg, arg1, arg2, ...)        &#x2F;&#x2F; call 用法func.apply(thisArg, [arg1, arg2, ...])     &#x2F;&#x2F; apply 用法</span><br></pre></td></tr></table></figure><p>看代码例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var person &#x3D; &#123;    &quot;name&quot;: &quot;koala&quot;&#125;;function changeJob(company, work) &#123;    this.company &#x3D; company;    this.work    &#x3D; work;&#125;;</span><br><span class="line">changeJob.call(person, &#39;百度&#39;, &#39;程序员&#39;);console.log(person.work); &#x2F;&#x2F; &#39;程序员&#39;</span><br><span class="line">changeJob.apply(person, [&#39;百度&#39;, &#39;测试&#39;]);console.log(person.work); &#x2F;&#x2F; &#39;测试&#39;</span><br></pre></td></tr></table></figure><h4 id="call和apply的注意点"><a href="#call和apply的注意点" class="headerlink" title="call和apply的注意点"></a>call和apply的注意点</h4><p>这两个方法在调用的时候，如果我们传入数字或者字符串，这两个方法会把传入的参数转成对象类型。</p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var number &#x3D; 1, string &#x3D; &#39;程序员成长指北&#39;;function getThisType () &#123;    var number &#x3D; 3;    console.log(&#39;this指向内容&#39;,this);    console.log(typeof this);&#125;getThisType.call(number);getThisType.apply(string); &#x2F;&#x2F; 输出结果&#x2F;&#x2F; this指向内容 [Number: 1]&#x2F;&#x2F; object&#x2F;&#x2F; this指向内容 [String: &#39;程序员成长指北&#39;]&#x2F;&#x2F; object</span><br></pre></td></tr></table></figure><h4 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h4><blockquote><p>bind 方法 会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。(定义内容来自于 MDN )</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func.bind(thisArg[, arg1[, arg2[, ...]]])    &#x2F;&#x2F; bind 用法</span><br></pre></td></tr></table></figure><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var publicAccounts &#x3D; &#123;    name: &#39;程序员成长指北&#39;,    author: &#39;koala&#39;,    subscribe: function(subscriber) &#123;        console.log(subscriber + this.name)    &#125;&#125;</span><br><span class="line">publicAccounts.subscribe(&#39;小红&#39;)   &#x2F;&#x2F; 输出结果: &quot;小红 程序员成长指北&quot;</span><br><span class="line">var subscribe1 &#x3D; publicAccounts.subscribe.bind(&#123; name: &#39;Node成长指北&#39;, author: &#39;考拉&#39; &#125;, &#39;小明 &#39;)subscribe1()       &#x2F;&#x2F; 输出结果: &quot;小明 Node成长指北&quot;</span><br></pre></td></tr></table></figure><h3 id="new-绑定"><a href="#new-绑定" class="headerlink" title="new 绑定"></a>new 绑定</h3><p>使用new调用函数的时候，会执行怎样的流程：</p><ol><li>创建一个空对象</li><li>将空对象的 proto 指向原对象的 prototype</li><li><code>执行构造函数中的代码</code></li><li>返回这个新对象</li></ol><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function study(name)&#123;    this.name &#x3D; name;</span><br><span class="line">&#125;var studyDay &#x3D; new study(&#39;koala&#39;);console.log(studyDay);console.log(&#39;Hello,&#39;, studyDay.name);&#x2F;&#x2F; 输出结果&#x2F;&#x2F; study &#123; name: &#39;koala&#39; &#125;&#x2F;&#x2F; hello，koala</span><br></pre></td></tr></table></figure><p>在 <code>newstudy(&#39;koala&#39;)</code>的时候，会改变this指向，将 <code>this指向指定到了studyDay对象</code>。注意:如果创建新的对象，构造函数不传值的话，新对象中的属性不会有值，但是新的对象中会有这个属性。</p><h4 id="手动实现一个new创建对象代码-多种实现方式哦"><a href="#手动实现一个new创建对象代码-多种实现方式哦" class="headerlink" title="手动实现一个new创建对象代码(多种实现方式哦)"></a>手动实现一个new创建对象代码(多种实现方式哦)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function New(func) &#123;    var res &#x3D; &#123;&#125;;    if (func.prototype !&#x3D;&#x3D; null) &#123;        res.__proto__ &#x3D; func.prototype;    &#125;    var ret &#x3D; func.apply(res, Array.prototype.slice.call(arguments, 1));    if ((typeof ret &#x3D;&#x3D;&#x3D; &quot;object&quot; || typeof ret &#x3D;&#x3D;&#x3D; &quot;function&quot;) &amp;&amp; ret !&#x3D;&#x3D; null) &#123;        return ret;    &#125;    return res;&#125;var obj &#x3D; New(A, 1, 2);&#x2F;&#x2F; equals tovar obj &#x3D; new A(1, 2);</span><br></pre></td></tr></table></figure><h2 id="this绑定优先级"><a href="#this绑定优先级" class="headerlink" title="this绑定优先级"></a>this绑定优先级</h2><p>上面介绍了 this 的四种绑定规则，但是一段代码有时候会同时应用多种规则，这时候 this 应该如何指向呢？其实它们也是有一个先后顺序的，具体规则如下:</p><p><strong>new绑定 &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定</strong></p><h2 id="箭头函数中的-this"><a href="#箭头函数中的-this" class="headerlink" title="箭头函数中的 this"></a>箭头函数中的 this</h2><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>在讲箭头函数中的 this 之前，先讲一下箭头函数。</p><p><strong>定义</strong></p><blockquote><p>MDN:箭头函数表达式的语法比函数表达式更短，并且不绑定自己的this，arguments，super或 new.target。这些函数表达式最适合用于非方法函数(non-method functions)，并且它们不能用作构造函数。</p></blockquote><ul><li>箭头函数中没有 arguments</li></ul><p>常规函数可以直接拿到 arguments 属性，但是在箭头函数中如果使用 arguments 属性，拿到的是箭头函数外层函数的 arguments 属性。</p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function constant() &#123;    return () &#x3D;&gt; arguments[0]&#125;</span><br><span class="line">let result &#x3D; constant(1);console.log(result()); &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure><p><strong>如果我们就是要访问箭头函数的参数呢？</strong></p><p>你可以通过 ES6 中 命名参数 或者 rest 参数的形式访问参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let nums &#x3D; (...nums) &#x3D;&gt; nums;</span><br></pre></td></tr></table></figure><ul><li>箭头函数没有构造函数</li></ul><p>箭头函数与正常的函数不同，箭头函数没有构造函数 constructor，因为没有构造函数，所以也不能使用 new 来调用，如果我们直接使用 new 调用箭头函数，会报错。</p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let fun &#x3D; ()&#x3D;&gt;&#123;&#125;let funNew &#x3D; new fun(); &#x2F;&#x2F; 报错内容 TypeError: fun is not a constructor</span><br></pre></td></tr></table></figure><ul><li>箭头函数没有原型</li></ul><p>原型 prototype 是函数的一个属性，但是对于箭头函数没有它。</p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let fun &#x3D; ()&#x3D;&gt;&#123;&#125;console.loh(fun.prototype); &#x2F;&#x2F; undefined</span><br></pre></td></tr></table></figure><ul><li>箭头函数中没有 super</li></ul><p>上面说了没有原型，连原型都没有，自然也不能通过 super 来访问原型的属性，所以箭头函数也是没有 super 的，不过跟 this、arguments、new.target 一样，这些值由外围最近一层非箭头函数决定。</p><ul><li><code>箭头函数中没有自己的this</code></li></ul><p>箭头函数中没有自己的 this，箭头函数中的 this 不能用 call()、apply()、bind() 这些方法改变 this 的指向，箭头函数中的 this 直接指向的是 <code>调用函数的上一层运行时</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; &#39;kaola&#39;</span><br><span class="line">let obj &#x3D; &#123;    a: &#39;程序员成长指北&#39;,    foo: () &#x3D;&gt; &#123;        console.log(this.a)    &#125;&#125;</span><br><span class="line">obj.foo()             &#x2F;&#x2F; 输出结果: &quot;koala&quot;</span><br></pre></td></tr></table></figure><p>看完输出结果，怕大家有疑问还是分析一下，前面我说的箭头函数中this直接指向的是 <code>调用函数的上一层运行时</code>，这段代码 <code>obj.foo</code>在调用的时候如果是不使用箭头函数this应该指向的是 obj ，但是使用了箭头函数，往上一层查找，指向的就是全局了，所以输出结果是 <code>koala</code>。</p><h3 id="自执行函数"><a href="#自执行函数" class="headerlink" title="自执行函数"></a>自执行函数</h3><p>什么是自执行函数？自执行函数在我们在代码只能够定义后，无需调用，会自动执行。开发过程中有时间测试某一小段代码报错会使用。代码例子如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;    console.log(&#39;程序员成长指北&#39;)&#125;)()</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;    console.log(&#39;程序员成长指北&#39;)&#125;())</span><br></pre></td></tr></table></figure><p>但是如果使用了箭头函数简化一下就只能使用第一种情况了。使用第二种情况简化会报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(() &#x3D;&gt; &#123;    console.log(&#39;程序员成长指北&#39;)&#125;)()</span><br></pre></td></tr></table></figure><h2 id="this应用场景"><a href="#this应用场景" class="headerlink" title="this应用场景"></a>this应用场景</h2><p>应用场景其实就是开篇说到的为什么写这篇文章，再重复一下。</p><ol><li>面试官他考！</li><li>看源码总看见，有时候想确认一下当前的上下文指向。为什么源码中用的多，大家可以想想这个问题。</li><li>我们写代码也会用，经常会出现用 call 指向某个对象的上下文，或者实现继承等等。</li></ol><h2 id="学后小练习"><a href="#学后小练习" class="headerlink" title="学后小练习"></a>学后小练习</h2><p>学到这里是不是发现开篇那道面试题有点简单，已经不能满足你目前对于 this 关键字的知识储备。好的，我们来一道复杂点的面试题。</p><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var length &#x3D; 10;function fn() &#123;    console.log(this.length);&#125;</span><br><span class="line">var obj &#x3D; &#123;  length: 5,  method: function(fn) &#123;    fn();    arguments[0]();  &#125;&#125;;</span><br><span class="line">obj.method(fn, 1);&#x2F;&#x2F;输出是什么？</span><br></pre></td></tr></table></figure><p>这段代码的输出结果是: <code>10,2</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>js系列三大家族</title>
      <link href="/2020/07/22/js%E7%B3%BB%E5%88%97%E4%B8%89%E5%A4%A7%E5%AE%B6%E6%97%8F/"/>
      <url>/2020/07/22/js%E7%B3%BB%E5%88%97%E4%B8%89%E5%A4%A7%E5%AE%B6%E6%97%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="1-1-三大家族和一个事件对象"><a href="#1-1-三大家族和一个事件对象" class="headerlink" title="1.1 三大家族和一个事件对象"></a>1.1 三大家族和一个事件对象</h1><p>三大家族（offset/scroll/client）</p><p>事件对象/event  （事件被触动时，鼠标和键盘的状态）（通过属性控制）</p><h1 id="1-2-Offset家族简介"><a href="#1-2-Offset家族简介" class="headerlink" title="1.2 Offset家族简介"></a>1.2 Offset家族简介</h1><p>offset这个单词本身是–偏移，补偿，位移的意思。</p><p>js中有一套方便的获取元素尺寸的办法就是offset家族；</p><p>offsetWidth和offsetHight以及offsetLeft和offsetTop以及offsetParent</p><p>共同组成了offset家族。</p><h3 id="1-2-1-offsetWidth和offsetHight-（检测盒子自身宽高-padding-border）"><a href="#1-2-1-offsetWidth和offsetHight-（检测盒子自身宽高-padding-border）" class="headerlink" title="1.2.1 offsetWidth和offsetHight （检测盒子自身宽高+padding+border）"></a>1.2.1 offsetWidth和offsetHight （检测盒子自身宽高+padding+border）</h3><p>这两个属性，他们绑定在了所有的节点元素上。获取之后，只要调用这两个属性，我们就能够获取元素节点的宽和高。</p><p>offset宽/高 = 盒子自身的宽/高 + padding+border；</p><p>offsetWidth =width+padding+border；</p><p>offsetHeight =Height+padding+border；</p><h3 id="1-2-2-offsetLeft和offsetTop-（检测距离父盒子有定位的左-上面的距离）"><a href="#1-2-2-offsetLeft和offsetTop-（检测距离父盒子有定位的左-上面的距离）" class="headerlink" title="1.2.2 offsetLeft和offsetTop （检测距离父盒子有定位的左/上面的距离）"></a>1.2.2 offsetLeft和offsetTop （检测距离父盒子有定位的左/上面的距离）</h3><p>返回距离上级盒子（带有定位）左边s的位置</p><p>如果父级都没有定位则以body为准</p><p>offsetLeft 从父亲的padding 开始算,父亲的border 不算。</p><p>在父盒子有定位的情况下，offsetLeft == style.left(去掉px)</p><h3 id="1-2-3-offsetParent-（检测父系盒子中带有定位的父盒子节点）"><a href="#1-2-3-offsetParent-（检测父系盒子中带有定位的父盒子节点）" class="headerlink" title="1.2.3 offsetParent  （检测父系盒子中带有定位的父盒子节点）"></a>1.2.3 offsetParent  （检测父系盒子中带有定位的父盒子节点）</h3><p>1、返回改对象的父级 （带有定位）</p><p>​     如果当前元素的父级元素没有进行CSS定位 （position为absolute或       relative，fixed），  offsetParent为body。</p><p>2、如果当前元素的父级元素中有CSS定位    （position为absolute或          relative，fixed），  offsetParent取最近的那个父级元素。</p><h1 id="1-3-offsetLeft和style-left区别"><a href="#1-3-offsetLeft和style-left区别" class="headerlink" title="1.3 offsetLeft和style.left区别"></a>1.3 offsetLeft和style.left区别</h1><p>一、最大区别在于offsetLeft可以返回没有定位盒子的距离左侧的位置。</p><p>而 style.left不可以</p><p>二、offsetTop 返回的是数字，而 style.top 返回的是字符串，除了数字外还带有单位：px。</p><p>三、offsetTop 只读，而 style.top 可读写。（只读是获取值，可写是赋值）</p><p>四、如果没有给 HTML 元素指定过 top 样式，则style.top 返回的是空字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">style.left在&#x3D;的左边和右边还不一样。（左边的时候是属性，右边的时候是值）</span><br></pre></td></tr></table></figure><h1 id="Scroll家族组成"><a href="#Scroll家族组成" class="headerlink" title="Scroll家族组成"></a>Scroll家族组成</h1><p>ScrollWidth和scrollHeight（不包括border）</p><p>检测盒子的宽高。（调用者：节点元素。属性。）</p><p>盒子内容的宽高。（如果有内容超出了，显示内容的高度）</p><p>IE567可以比盒子小。 IE8+火狐谷歌不能比盒子小</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="scrollLeft和scrollTop"><a href="#scrollLeft和scrollTop" class="headerlink" title="scrollLeft和scrollTop"></a>scrollLeft和scrollTop</h2><p>网页，被浏览器遮挡的头部和左边部分。</p><p>被卷去的头部和左边部分。</p><p>兼容性问题</p><p>一、未声明 DTD（谷歌只认识他）</p><p>document.body.scrollTop</p><p>二、已经声明DTD（IE678只认识他）</p><p>  document.documentElement.scrollTop</p><p>三、火狐/谷歌/ie9+以上支持的</p><p>  window.pageYOffset</p><h2 id="兼容写法"><a href="#兼容写法" class="headerlink" title="兼容写法"></a>兼容写法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var aaa &#x3D; window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var aaa &#x3D; document.documentElement.scrollTop + document.body.scrollTop;</span><br></pre></td></tr></table></figure><p>事件event</p><h2 id="1-1-事件对象的获取（event的获取）"><a href="#1-1-事件对象的获取（event的获取）" class="headerlink" title="1.1  事件对象的获取（event的获取）"></a>1.1  事件对象的获取（event的获取）</h2><p>IE678中，window.event</p><p>在火狐谷歌中，event或者，在事件绑定的函数中，加参，这个参数就是event.</p><p> Box.onclick = function (aaa){  aaa就是event   }</p><h2 id="1-2-兼容获取方式有两种："><a href="#1-2-兼容获取方式有两种：" class="headerlink" title="1.2  兼容获取方式有两种："></a>1.2  兼容获取方式有两种：</h2><p>不写参数直接使用event;</p><p>写参数，但是为event….var  event = event || window.event;(主要用这种)</p><h2 id="1-3-event内容重要内容"><a href="#1-3-event内容重要内容" class="headerlink" title="1.3  event内容重要内容"></a>1.3  event内容重要内容</h2><p><img src= "/img/loading.gif" data-src="https://img-blog.csdn.net/20170330141538969?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvV1ppb3M=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p>PageY/pageX: 鼠标位于整个网页页面的顶部和左侧部分的距离。（页面）</p><p>ScreenY/screenX: 鼠标位于屏幕的上方和左侧的距离。（屏幕）</p><p>ClientX/clientY: 鼠标位于浏览器的左侧和顶部的距离。（浏览器大小和位置）</p><h2 id="1-1-PageY和pageX的兼容写法（很重要）"><a href="#1-1-PageY和pageX的兼容写法（很重要）" class="headerlink" title="1.1  PageY和pageX的兼容写法（很重要）"></a>1.1  PageY和pageX的兼容写法（很重要）</h2><p>在页面位置就等于 = 看得见的+看不见的</p><p>pageY/pageX=event.clientY/clientX+scroll().top/scroll().left</p><h1 id="client家族"><a href="#client家族" class="headerlink" title="client家族"></a>client家族</h1><h2 id="1-1-主要成员"><a href="#1-1-主要成员" class="headerlink" title="1.1 主要成员"></a>1.1 主要成员</h2><p>1、clientWidth  获取网页可视区域宽度（两种用法）</p><p>  clientHeight 获取网页可视区域高度（两种用法）</p><p>   调用者不同，意义不同：</p><p>​           盒子调用：       指盒子本身。</p><p>​           body/html调用：    可视区域大小。 </p><p>2、clientX    鼠标距离可视区域左侧距离（event调用）</p><p>  clientY   鼠标距离可视区域上侧距离（event调用）</p><p>3、clientTop/clientLeft      盒子的border宽高</p><h2 id="1-2-三大家族区别（三大家族总结）"><a href="#1-2-三大家族区别（三大家族总结）" class="headerlink" title="1.2 三大家族区别（三大家族总结）"></a>1.2 三大家族区别（三大家族总结）</h2><h3 id="1-2-1-Width和height"><a href="#1-2-1-Width和height" class="headerlink" title="1.2.1 Width和height"></a>1.2.1 Width和height</h3><p>clientWidth = width + padding</p><p>clientHeight = height + padding</p><p>offsetWidth = width + padding + border</p><p>offsetHeight = height + padding + border</p><p>scrollWidth  = 内容宽度（不包含border）width + padding</p><p>scrollHeight = 内容高度（不包含border）</p><h3 id="1-2-2-top和left"><a href="#1-2-2-top和left" class="headerlink" title="1.2.2 top和left"></a>1.2.2 top和left</h3><p>offsetTop/offsetLeft：</p><p>​     调用者：任意元素。(盒子为主)</p><p>​     作用：距离父系盒子中带有定位的距离。</p><p>scrollTop/scrollLeft:(盒子也可以调用，必须有滚动条)</p><p>​     调用者：document.body.scrollTop/…..(window)</p><p>​     作用：浏览器无法显示的部分（被卷去的部分）。</p><p>clientY/clientX:（clientTop/clientLeft 值的是border）</p><p>​     调用者：event.clientX(event)</p><p>​     作用：鼠标距离浏览器可视区域的距离（左、上）。</p><p>//   width和height<br>//   offset带border<br>//   scroll不带border，内容的宽高<br>//   client不带border</p><p>//   top和left<br>//   offset距离父系盒子带有定位的盒子之间的距离<br>//   scroll被卷去的部分的距离<br>//   clientborder的宽高</p><p>  //clientX和clientY<br>//   event调用，鼠标距离浏览器的可视区域的距离</p><h2 id="1-3-client家族特殊用法之-检浏览器宽-高度-可视区域"><a href="#1-3-client家族特殊用法之-检浏览器宽-高度-可视区域" class="headerlink" title="1.3 client家族特殊用法之:检浏览器宽/高度(可视区域)"></a>1.3 client家族特殊用法之:检浏览器宽/高度(可视区域)</h2><p><img src= "/img/loading.gif" data-src="https://img-blog.csdn.net/20170331094037076?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvV1ppb3M=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><h2 id="1-4-Onresize事件"><a href="#1-4-Onresize事件" class="headerlink" title="1.4 Onresize事件"></a>1.4 Onresize事件</h2><p>只要浏览器的大小改变，哪怕1像素，都会触动这个事件。</p><h2 id="1-5-案例：根据浏览器可视区域大小，给定背景色"><a href="#1-5-案例：根据浏览器可视区域大小，给定背景色" class="headerlink" title="1.5 案例：根据浏览器可视区域大小，给定背景色"></a>1.5 案例：根据浏览器可视区域大小，给定背景色</h2><h2 id="1-6-事件总结"><a href="#1-6-事件总结" class="headerlink" title="1.6 事件总结"></a>1.6 事件总结</h2><p>区分：</p><p>  1.window.onscroll     屏幕滑动</p><p>  2.window.onresize      浏览器大小变化</p><p>  3.window.onload     页面加载完毕</p><p>  4.div.onmousemove     鼠标在盒子上移动</p><p>​     （注意：不是盒子移动！！！）</p><p> 5.onmouseup/onmousedown == onclick</p><h2 id="1-7-获得屏幕宽高"><a href="#1-7-获得屏幕宽高" class="headerlink" title="1.7 获得屏幕宽高"></a>1.7 获得屏幕宽高</h2><p>window.screen.width</p><p>分辨率是屏幕图像的精密度，指显示器所能显示的像素有多少。</p><p>   我们的电脑一般：</p><p>横向1280个像素点，</p><p>纵向960个像素点。</p><p>我们看电影的时候是满屏和半屏的，就是这。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>js数组去重的几种方式</title>
      <link href="/2020/07/22/js%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
      <url>/2020/07/22/js%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="1-遍历数组法"><a href="#1-遍历数组法" class="headerlink" title="1.遍历数组法"></a><strong>1.遍历数组法</strong></h3><p>它是最简单的数组去重方法（indexOf方法）</p><p>实现思路：新建一个数组，遍历去要重的数组，当值不在新数组的时候（indexOf为-1）就加入该新数组中；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var arr&#x3D;[2,8,5,0,5,2,6,7,2];</span><br><span class="line">function unique1(arr)&#123;</span><br><span class="line">  var hash&#x3D;[];</span><br><span class="line">  for (var i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">     if(hash.indexOf(arr[i])&#x3D;&#x3D;-1)&#123;</span><br><span class="line">      hash.push(arr[i]);</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-数组下标判断法"><a href="#2-数组下标判断法" class="headerlink" title="2.数组下标判断法"></a><strong>2.数组下标判断法</strong></h3><p>调用indexOf方法，性能和方法1差不多</p><p>实现思路：如果当前数组的第 i 项在当前数组中第一次出现的位置不是 i，那么表示第 i 项是重复的，忽略掉。否则存入结果数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function unique2(arr)&#123;</span><br><span class="line">  var hash&#x3D;[];</span><br><span class="line">  for (var i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">     if(arr.indexOf(arr[i])&#x3D;&#x3D;i)&#123;</span><br><span class="line">      hash.push(arr[i]);</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-排序后相邻去除法"><a href="#3-排序后相邻去除法" class="headerlink" title="3.排序后相邻去除法"></a><strong>3.排序后相邻去除法</strong></h3><p>实现思路：给传入的数组排序，排序后相同的值会相邻，然后遍历排序后数组时，新数组只加入不与前一值重复的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function unique3(arr)&#123;</span><br><span class="line">  arr.sort();</span><br><span class="line">  var hash&#x3D;[arr[0]];</span><br><span class="line">  for (var i &#x3D; 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">     if(arr[i]!&#x3D;hash[hash.length-1])&#123;</span><br><span class="line">      hash.push(arr[i]);</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-优化遍历数组法"><a href="#4-优化遍历数组法" class="headerlink" title="4.优化遍历数组法"></a><strong>4.优化遍历数组法</strong></h3><p>实现思路：双层循环，外循环表示从0到arr.length，内循环表示从i+1到arr.length</p><p>将没重复的右边值放入新数组。（检测到有重复值时终止当前循环同时进入外层循环的下一轮判断）</p><p>quan_lst 里面是一个一个的js字面量对象，根据json里面的属性进行判定去重</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function unique(quan_lst)&#123;    </span><br><span class="line">&#x2F;&#x2F;去掉重复选取的数据</span><br><span class="line">    for (var i &#x3D; 0; i &lt; quan_lst.length; i++) &#123;</span><br><span class="line">        for (var j &#x3D;i+1; j &lt;quan_lst.length; ) &#123;</span><br><span class="line">            if (quan_lst[i].photoid &#x3D;&#x3D; quan_lst[j].photoid ) &#123;&#x2F;&#x2F;通过photoid属性进行匹配；</span><br><span class="line">                quan_lst.splice(j, 1);&#x2F;&#x2F;去除重复的对象；</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-ES6实现"><a href="#5-ES6实现" class="headerlink" title="5.ES6实现"></a><strong>5.ES6实现</strong></h3><p>基本思路：ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p><p>Set函数可以接受一个数组（或类似数组的对象）作为参数，用来初始化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function unique5(arr)&#123;</span><br><span class="line">  var x &#x3D; new Set(arr);</span><br><span class="line"> return [...x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 扩展：如果重复，则去掉该元素</p><p>数组下标去重</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function unique22(arr)&#123;</span><br><span class="line">  var hash&#x3D;[];</span><br><span class="line">  for (var i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">     if(arr.indexOf(arr[i])&#x3D;&#x3D;arr.lastIndexOf(arr[i]))&#123;</span><br><span class="line">      hash.push(arr[i]);</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补充：原先自己一直以为indexOf是针对字符串，原来indexOf也可以查询出数组元素所在的数组中的位置(以0开始计算),</p><h3 id="6-ES6实现（第二种方式）"><a href="#6-ES6实现（第二种方式）" class="headerlink" title="6.ES6实现（第二种方式）"></a><strong>6.ES6实现</strong>（第二种方式）</h3><pre><code>var arr = [1,1,8,8,12,12,15,15,16,16];</code></pre><p>function unique (arr) {<br>  return Array.from(new Set(arr))<br>}</p><p>console.log(unique(arr))<br> //[1,8,12,15,16]</p><h3 id="7-利用includes"><a href="#7-利用includes" class="headerlink" title="7.利用includes"></a><strong>7.利用includes</strong></h3><p>var arr = [1, 1, 8, 8, 12, 12, 15, 15, 16, 16];<br>function unique(arr) {<br>    if (!Array.isArray(arr)) {<br>        console.log(‘type error!’)<br>        return<br>    }<br>    var array =[];<br>    for(var i = 0; i &lt; arr.length; i++) {<br>            if( !array.includes( arr[i]) ) {//includes 检测数组是否有某个值<br>                    array.push(arr[i]);<br>              }<br>    }<br>    return array<br>}<br>console.log(unique(arr))</p><h3 id="8-利用filter"><a href="#8-利用filter" class="headerlink" title="8.利用filter"></a>8.利用filter</h3><p>var arr = [1, 1, 8, 8, 12, 12, 15, 15, 16, 16];<br>function unlink(arr) {<br>    return arr.filter(function (item, index, arr) {<br>        //当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素<br>        return arr.indexOf(item, 0) === index;<br>    });<br>}<br>console.log(unlink(arr));</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>js实现几种排序算法</title>
      <link href="/2020/07/22/js%E5%AE%9E%E7%8E%B0%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2020/07/22/js%E5%AE%9E%E7%8E%B0%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="js实现几种排序算法"><a href="#js实现几种排序算法" class="headerlink" title="js实现几种排序算法"></a><a href="https://www.cnblogs.com/golden-wind/p/3289538.html" target="_blank" rel="noopener">js实现几种排序算法</a></h1><p>从排序的方法来讲：一般分为交换、插入、选择、合并等，交换方式的排序有：冒泡排序、快速排序；插入方式的排序有：希尔排序；选择方式的排序有：堆排序。</p><h2 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a><strong>1.冒泡排序</strong></h2><p>算法原理描述：比较相邻的元素。如果第一个比第二个大，就交换他们两个。第一对做完后，然后对第二对（即第二个数和第三个数）比较，若前一个比后一个大，就交换他们，依次对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。最后的元素应该会是最大的数，最后一个不需要再做比较，所以是比较length-1次。</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200629102206363.png" alt="image-20200629102206363"></p><h2 id="2-快速排序"><a href="#2-快速排序" class="headerlink" title="2.快速排序"></a><strong>2.快速排序</strong></h2><p>算法原理描述：找到一个中间的数，然后把所有比这个数小的放到这个数前面，把所有比这个数大的放到后面，这样完成一趟，依次对前面一段数据和后面一段数据进行前面步骤的递归。</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200629103048497.png" alt="image-20200629103048497"></p><h2 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3.插入排序"></a><strong>3.插入排序</strong></h2><p>排序原理描述：将一系列无序的元素，往一个有序的元素序列里面插入，形成一个有序的序列。插入的时候，将无序的元素序列中每个元素依次和有序的数组最后一个元素开始比较，如果比该元素小，则和该元素交换位置，依次比较，找到一个最合适的位置，即比前一个元素大，比后一个元素小。</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200629103607519.png" alt="image-20200629103607519"></p><h2 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4.希尔排序"></a><strong>4.希尔排序</strong></h2><p>算法原理描述：先取一个小于n的整数d1作为第一个<a href="https://baike.baidu.com/item/增量" target="_blank" rel="noopener">增量</a>，把文件的全部记录分组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行<a href="https://baike.baidu.com/item/直接插入排序" target="_blank" rel="noopener">直接插入排序</a>；然后，取第二个增量d2&lt;d1重复上述的分组和排序，直至所取的增量dt=1(dt &lt; …&lt;d2&lt;d1)即所有记录放在同一组中进行直接插入排序为止。</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200629105304218.png" alt="image-20200629105304218"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200629105629286.png" alt="image-20200629105629286"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>js的继承方式</title>
      <link href="/2020/07/22/js%E7%9A%84%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F/"/>
      <url>/2020/07/22/js%E7%9A%84%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1.原型链继承"></a>1.原型链继承</h2><pre><code>在js中,继承是基于原型来实现的,我们称之为原型继承.        继承的意义:        1.共享父级的资源(数据)        2.拓展父级的属性和功能</code></pre><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200630110737626.png" alt="image-20200630110737626"></p><h2 id="2-call-apply方法实现继承"><a href="#2-call-apply方法实现继承" class="headerlink" title="2.call/apply方法实现继承"></a>2.call/apply方法实现继承</h2><pre><code>/* 小节:         * 原型继承实现了数据的共享,         * 但是也有缺陷:因为改变了原型的指向,同时实现了继承,直接初始化了属性,继承过来的属性值都是一样的         * ,所以问题就出现了.         * 只能通过调用对象的属性进行重新赋值才能解决,比较麻烦 - 例如:stu2    &lt;!--        以上的操作有解决方案:        继承的时候,不用改变指向,直接调用父级的构造函数的方式对属性进行赋值        借用构造函数:把要继承的父级的构造函数拿过来,直接使用一下.        使用父级的构造函数:        语法: 构造函数的名字.call(当前对象,属性,属性,属性,.......)        解决了属性的继承,并且值不重复        缺陷:父级中的原型方法不能被继承</code></pre><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200630111146860.png" alt="image-20200630111146860"></p><h2 id="3-圣杯模式"><a href="#3-圣杯模式" class="headerlink" title="3.圣杯模式"></a>3.圣杯模式</h2><p><strong>javascript纯面向对象开发需要使用到的一个模式，来对对象之间原型继承做中间层代理避免重复继承与代码杂乱</strong></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200630111610530.png" alt="image-20200630111610530"></p><h2 id="4-组合继承"><a href="#4-组合继承" class="headerlink" title="4.组合继承"></a>4.组合继承</h2><p><strong>组合 原型链继承 和 借用构造函数继承</strong><br><strong>背后的思路是：使用原型链实现对原型方法的继承，而通过借用构造函数来实现对实例属性的继承。</strong></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200630133439670.png" alt="image-20200630133439670"></p><h2 id="5-寄生式继承"><a href="#5-寄生式继承" class="headerlink" title="5.寄生式继承"></a><strong>5.寄生式继承</strong></h2><p><strong>重点：就是给原型式继承外面套了个壳子。</strong></p><p><strong>优点：没有创建自定义类型，因为只是套了个壳子返回对象，这个函数顺理成章就成了创建的新对象。</strong></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200630133253974.png" alt="image-20200630133253974"></p><h2 id="6-拷贝继承"><a href="#6-拷贝继承" class="headerlink" title="6.拷贝继承"></a>6.拷贝继承</h2><p><strong>拷贝继承其实就是把一个对象中的属性和方法复制到另一个对象中</strong></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200630150425169.png" alt="image-20200630150425169"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200630150459057.png" alt="image-20200630150459057"></p><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>面向对象的特性:封装,继承,多态<br>            继承:类与类之间的关系,面向对象的语言中继承是为了多态服务的.<br>            在js中,不是纯面向对象语言,但是可以模拟对象,模拟继承,目的是为了共享数据节省空间.</p><pre><code>继承:原型作用一:数据共享,目的是为了节省内存空间.原型作用二:继承,目的是为了节省内存空间.继承的方式:原型继承:改变原型的指向借用构造函数继承:主要是解决原型继承中属性值的缺陷组合继承:原型继承 + 借用构造函数继承 - 解决属性和方法的问题(借用构造函数继承的不足点)拷贝继承:就是把对象中的需要共享的数据(属性和方法),直接遍历的方式复制到另一个对象中. </code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JS 中的闭包与模块</title>
      <link href="/2020/07/22/JS%20%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85%E4%B8%8E%E6%A8%A1%E5%9D%97/"/>
      <url>/2020/07/22/JS%20%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85%E4%B8%8E%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h2 id="JS-中的闭包与模块"><a href="#JS-中的闭包与模块" class="headerlink" title="JS 中的闭包与模块"></a>JS 中的闭包与模块</h2><p>全局变量使用容易引发bug，咱们经常教导尽量不要使用全局变量，尽管全局变量在某些情况下是有用的。例如，在浏览器中使用JS时，咱们可以访问全局<code>window</code>对象，<code>window</code>中有很多有用的方法，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">window.alert(&#39;Hello world&#39;); &#x2F;&#x2F; Shows an alert</span><br><span class="line">window.setTimeout(callback, 3000); &#x2F;&#x2F; Delay execution</span><br><span class="line">window.fetch(someUrl); &#x2F;&#x2F; make XHR requests</span><br><span class="line">window.open(); &#x2F;&#x2F; Opens a new tab</span><br></pre></td></tr></table></figure><p>这些方法也像这样使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert(&#39;Hello world&#39;); &#x2F;&#x2F; Shows an alert</span><br><span class="line">setTimeout(callback, 3000); &#x2F;&#x2F; Delay execution</span><br><span class="line">fetch(someUrl); &#x2F;&#x2F; make XHR requests</span><br><span class="line">open(); &#x2F;&#x2F; Opens a new tab</span><br></pre></td></tr></table></figure><p>这是方便的。<code>Redux</code>是另一个“好”全局变量的例子:整个应用程序的状态存储在一个JS对象中，这个对象可以从整个应用程序(通过Redux)访问。但是当在一个团队如果同时有50个编写代码时，以如何处理这样的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr &#x3D; [];</span><br><span class="line"></span><br><span class="line">function addToArr(element) &#123;</span><br><span class="line">  arr.push(element);</span><br><span class="line">  return element + &quot; added!&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>咱们同事在另一个文件中创建一个名为<code>arr</code>的新全局数组的几率有多大?我觉得非常高。JS中的全局变量非常糟糕的另一个原因是引擎足够友好，可以为咱们创建全局变量。如果忘了在变量名前加上<code>var</code>，就像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name &#x3D; &quot;Valentino&quot;;</span><br></pre></td></tr></table></figure><p>JS引擎为会创建一个全局变量，更糟糕的是，可以在函数中创建了“非预期”变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function doStuff() &#123;</span><br><span class="line">  name &#x3D; &quot;Valentino&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doStuff();</span><br><span class="line"></span><br><span class="line">console.log(name); &#x2F;&#x2F; &quot;Valentino&quot;</span><br></pre></td></tr></table></figure><p>无辜的功能最终污染了全球环境。幸运的是，可以用“严格模式”来消除这种行为， 在每个JS文件使用<code>“use strict”</code>足以避免愚蠢的错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line"></span><br><span class="line">function doStuff() &#123;</span><br><span class="line">  name &#x3D; &quot;Valentino&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doStuff();</span><br><span class="line"></span><br><span class="line">console.log(name); &#x2F;&#x2F; ReferenceError: name is not defined</span><br></pre></td></tr></table></figure><p>但一直使用严格模式也是一个问题，并不确实每个开发人员都会使用严格模式，因此，咱们必须找到一种解决“全局变量污染”问题的方法，幸运的是，JS 一直有一个内置的机制来解决这个问题。</p><h2 id="揭秘闭包"><a href="#揭秘闭包" class="headerlink" title="揭秘闭包"></a>揭秘闭包</h2><p>那么，咱们如何保护全局变量不被污染?让咱们从一个简单的解开始，把<code>arr</code>移动到一个函数中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function addToArr(element) &#123;</span><br><span class="line">  var arr &#x3D; [];</span><br><span class="line">  arr.push(element);</span><br><span class="line">  return element + &quot; added to &quot; + arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>似乎合理，但结果不是咱们所期望的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var firstPass &#x3D; addToArr(&quot;a&quot;);</span><br><span class="line">var secondPass &#x3D; addToArr(&quot;b&quot;);</span><br><span class="line">console.log(firstPass); &#x2F;&#x2F; a added to a</span><br><span class="line">console.log(secondPass); &#x2F;&#x2F; b added to b</span><br></pre></td></tr></table></figure><p><code>arr</code>在每次函数调用时都会被重置，现在它成了一个局部变量，而在第一个例子中咱们声明的<code>arr</code>是全局变量。全局变量是“实时的”，不会被重围。局部变量在函数执行完后就会被销毁了似乎没有办法防止局部变量被破坏？闭包会有帮助吗？但是什么是 闭包呢？</p><p>JS函数可以包含其他函数，这到现在是很常见的，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function addToArr(element) &#123;</span><br><span class="line">  var arr &#x3D; [];</span><br><span class="line"></span><br><span class="line">  function push() &#123;</span><br><span class="line">    arr.push(element);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return element + &quot; added to &quot; + arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但如果咱们直接把 <code>push</code> 函数返回，又会怎么样呢？如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function addToArr(element) &#123;</span><br><span class="line">  var arr &#x3D; [];</span><br><span class="line"></span><br><span class="line">  return function push() &#123;</span><br><span class="line">    arr.push(element);</span><br><span class="line">    console.log(arr);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;return element + &quot; added to &quot; + arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>外部函数变成一个容器，返回另一个函数。第二个<code>return</code>语句被注释，因为该代码永远不会被执行。此时，咱们知道函数调用的结果可以保存在变量中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var result &#x3D; addToArr();</span><br></pre></td></tr></table></figure><p>现在<code>result</code>变成了一个可执行的JS函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var result &#x3D; addToArr();</span><br><span class="line">result(&quot;a&quot;);</span><br><span class="line">result(&quot;b&quot;);</span><br></pre></td></tr></table></figure><p>只需修复一下，将参数“<code>element</code>”从外部函数移动到内部函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function addToArr() &#123;</span><br><span class="line">  var arr &#x3D; [];</span><br><span class="line"></span><br><span class="line">  return function push(element) &#123;</span><br><span class="line">    arr.push(element);</span><br><span class="line">    console.log(arr);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;return element + &quot; added to &quot; + arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>神奇的现象出现了，完整代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function addToArr() &#123;</span><br><span class="line">  var arr &#x3D; [];</span><br><span class="line"></span><br><span class="line">  return function push(element) &#123;</span><br><span class="line">    arr.push(element);</span><br><span class="line">    console.log(arr);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;return element + &quot; added to &quot; + arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var result &#x3D; addToArr();</span><br><span class="line">result(&quot;a&quot;); &#x2F;&#x2F; [ &#39;a&#39; ]</span><br><span class="line">result(&quot;b&quot;); &#x2F;&#x2F; [ &#39;a&#39;, &#39;b&#39; ]</span><br></pre></td></tr></table></figure><p>这种被称为JS闭包:一个能够记住其环境变量的函数。为此，内部函数必须是一个封闭(外部)函数的返回值。这种也称为<strong>工厂函数</strong>。代码可以稍作调整，变更可以取更好的命名，内部函数可以是匿名的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function addToArr() &#123;</span><br><span class="line">  var arr &#x3D; [];</span><br><span class="line"></span><br><span class="line">  return function(element) &#123;</span><br><span class="line">    arr.push(element);</span><br><span class="line">    return element + &quot; added to &quot; + arr;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var closure &#x3D; addToArr();</span><br><span class="line">console.log(closure(&quot;a&quot;)); &#x2F;&#x2F; a added to a</span><br><span class="line">console.log(closure(&quot;b&quot;)); &#x2F;&#x2F; b added to a,b</span><br></pre></td></tr></table></figure><p>现在应该清楚了，“<code>闭包</code>”是内部函数。但有一个问题需要解决:咱们为什么要这样做?JS闭包的真正目的是什么?</p><h2 id="闭包的需要"><a href="#闭包的需要" class="headerlink" title="闭包的需要"></a>闭包的需要</h2><p>除了纯粹的“学术”知识之外，JS闭包还有很多用处：</p><ul><li>提供私有的全局变量</li><li>在函数调用之间保存变量(状态)</li></ul><p>JS中闭包最有趣的应用程序之一是<code>模块模式</code>。在ES6之前，除了将变量和方法封装在函数中之外，没有其他方法可以模块化JS代码并提供私有变量与方法”。闭包与立即调用的函数表达式相结合 是至今通用解决方案。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var Person &#x3D; (function()&#123;</span><br><span class="line">  &#x2F;&#x2F; do something</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>在模块中可以有“私有”变量和方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var Person &#x3D; (function() &#123;</span><br><span class="line">  var person &#x3D; &#123;</span><br><span class="line">    name: &quot;&quot;,</span><br><span class="line">    age: 0</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  function setName(personName) &#123;</span><br><span class="line">    person.name &#x3D; personName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function setAge(personAge) &#123;</span><br><span class="line">    person.age &#x3D; personAge;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>从外部咱们无法访问<code>person.name</code>或<code>person.age</code>。咱们也不能调用<code>setName</code>或<code>setAge</code>。模块内的所有内容都是“私有的”。如果想公开咱们的方法，我们可以返回一个包含对私有方法引用的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var Person &#x3D; (function() &#123;</span><br><span class="line">  var person &#x3D; &#123;</span><br><span class="line">    name: &quot;&quot;,</span><br><span class="line">    age: 0</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  function setName(personName) &#123;</span><br><span class="line">    person.name &#x3D; personName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function setAge(personAge) &#123;</span><br><span class="line">    person.age &#x3D; personAge;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return &#123;</span><br><span class="line">    setName: setName,</span><br><span class="line">    setAge: setAge</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>如果想获取<code>person</code>对象，添加一个获取 <code>person</code> 对象的方法并返回即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">var Person &#x3D; (function() &#123;</span><br><span class="line">  var person &#x3D; &#123;</span><br><span class="line">    name: &quot;&quot;,</span><br><span class="line">    age: 0</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  function setName(personName) &#123;</span><br><span class="line">    person.name &#x3D; personName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function setAge(personAge) &#123;</span><br><span class="line">    person.age &#x3D; personAge;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getPerson() &#123;</span><br><span class="line">    return person.name + &quot; &quot; + person.age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return &#123;</span><br><span class="line">    setName: setName,</span><br><span class="line">    setAge: setAge,</span><br><span class="line">    getPerson: getPerson</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">Person.setName(&quot;Tom&quot;);</span><br><span class="line">Person.setAge(44);</span><br><span class="line">var person &#x3D; Person.getPerson();</span><br><span class="line">console.log(person); &#x2F;&#x2F; Tom 44</span><br></pre></td></tr></table></figure><p>这种方式，外部获取不到 <code>person</code> 对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Person.person); &#x2F;&#x2F; undefined</span><br></pre></td></tr></table></figure><p>模块模式不是构造JS代码的唯一方式。使用对象，咱们可以实现相同的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var Person &#x3D; &#123;</span><br><span class="line">  name: &quot;&quot;,</span><br><span class="line">  age: 0,</span><br><span class="line">  setName: function(personName) &#123;</span><br><span class="line">    this.name &#x3D; personName;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; other methods here</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是这样，内部属性就不在是私有的了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var Person &#x3D; &#123;</span><br><span class="line">  name: &quot;&quot;,</span><br><span class="line">  age: 0,</span><br><span class="line">  setName: function(personName) &#123;</span><br><span class="line">    this.name &#x3D; personName;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; other methods here</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person.setName(&quot;Tom&quot;);</span><br><span class="line"></span><br><span class="line">console.log(Person.name); &#x2F;&#x2F; Tom</span><br></pre></td></tr></table></figure><p>这是模块的主要卖点之一。另一个好处是，模块有助于组织代码，使其具有重用性和可读性。如，开发人员看到以下的代码就大概知道是做什么的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line"></span><br><span class="line">var Person &#x3D; (function() &#123;</span><br><span class="line">  var person &#x3D; &#123;</span><br><span class="line">    name: &quot;&quot;,</span><br><span class="line">    age: 0</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  function setName(personName) &#123;</span><br><span class="line">    person.name &#x3D; personName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function setAge(personAge) &#123;</span><br><span class="line">    person.age &#x3D; personAge;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getPerson() &#123;</span><br><span class="line">    return person.name + &quot; &quot; + person.age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return &#123;</span><br><span class="line">    setName: setName,</span><br><span class="line">    setAge: setAge,</span><br><span class="line">    getPerson: getPerson</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>全局变量很容易引发bug，咱们应该尽可能地避免它们。有时全局变量是有用的，需要格外小心使用，因为JS引擎可以自由地创建全局变量。</p><p>这些年来出现了许多模式来管理全局变量，模块模式就是其中之一。模块模式建立在闭包上，这是JS的固有特性。JS 中的闭包是一种能够“记住”其变量环境的函数，即使在后续函数调用之间也是如此。当咱们从另一个函数返回一个函数时，会创建一个闭包，这个模式也称为<strong>“工厂函数</strong>”。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li>什么是闭包？</li><li>使用全局变量有哪些不好的方面？</li><li>什么是 JS 模块，为什么要使用它？</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2020/07/22/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2020/07/22/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="1-转义字符"><a href="#1-转义字符" class="headerlink" title="1.转义字符"></a>1.转义字符</h2><p><strong>:</strong>表示转义字符，如果想在字符串中“assssdcfdf”dddddd”输入双引号就需要转义字符</p><p><strong>\n</strong>：换行</p><p><strong>\r:</strong>   行结束符</p><p>*<em>\t: *</em>  制表符</p><p><strong>windows操作系统：回车等于\r+\n</strong>  <strong>linius操作系统：回车等于\n</strong></p><h3 id="打印多行字符串：利用转义字符"><a href="#打印多行字符串：利用转义字符" class="headerlink" title="打印多行字符串：利用转义字符"></a>打印多行字符串：利用转义字符</h3><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702222341405.png" alt="image-20200702222341405"></p><h2 id="2-正则表达式创建的两种方式"><a href="#2-正则表达式创建的两种方式" class="headerlink" title="2.正则表达式创建的两种方式"></a>2.正则表达式创建的两种方式</h2><p><strong>字面量：/pattern/</strong></p><p><strong>new关键字：new RegExp(“pattern”，“属性i,m,g”)</strong></p><p><strong>与Date类似，是一种匹配规则对象</strong></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702222753549.png" alt="image-20200702222753549"></p><p><strong>new RegExp()第一个参数还可以是一个已知的正则表达式</strong>，<strong>这时reg与reg1虽然打印结果一致，但是他们却是互不影响相互独立**</strong></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702224909098.png" alt="image-20200702224909098"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702225321952.png" alt="image-20200702225321952"></p><h2 id="3-正则表达式的匹配方法"><a href="#3-正则表达式的匹配方法" class="headerlink" title="3.正则表达式的匹配方法"></a>3.正则表达式的匹配方法</h2><h3 id="1-reg-test"><a href="#1-reg-test" class="headerlink" title="1.reg.test()"></a>1.reg.test()</h3><p><strong>含义：正则表达式规定一下该字符串中有没有我所规定的片段</strong></p><p><strong>结果:true/false</strong></p><h3 id="2-string-match（reg"><a href="#2-string-match（reg" class="headerlink" title="2.string.match（reg)"></a>2.string.match（reg)</h3><p><strong>含义：返回的是匹配的结果并且结果是以数组的方式展示的</strong></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702230037496.png" alt="image-20200702230037496"></p><h2 id="4-正则表达式的属性"><a href="#4-正则表达式的属性" class="headerlink" title="4.正则表达式的属性"></a>4.正则表达式的属性</h2><h3 id="1-后面加i（ignore-Case-忽视大小写）"><a href="#1-后面加i（ignore-Case-忽视大小写）" class="headerlink" title="1./后面加i（ignore Case 忽视大小写）"></a>1./后面加i（ignore Case 忽视大小写）</h3><p><strong>例如：/absdDDBn/i  表示忽略大小写</strong></p><h3 id="2-后面加g（全局匹配）"><a href="#2-后面加g（全局匹配）" class="headerlink" title="2./后面加g（全局匹配）"></a>2./后面加g（全局匹配）</h3><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702230140126.png" alt="image-20200702230140126"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702230228837.png" alt="image-20200702230228837"></p><h3 id="3-后面加m（多行匹配）"><a href="#3-后面加m（多行匹配）" class="headerlink" title="3./后面加m（多行匹配）"></a>3./后面加m（多行匹配）</h3><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702230523920.png" alt="image-20200702230523920"></p><p><strong>此时的结果还是a</strong></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702230614736.png" alt="image-20200702230614736"></p><p><strong>加上m就是数组中有两个a</strong></p><h2 id="5-表达式"><a href="#5-表达式" class="headerlink" title="5.表达式"></a>5.表达式</h2><h3 id="：一个-代表一位"><a href="#：一个-代表一位" class="headerlink" title="[]：一个[]代表一位**"></a>[]：一个[]代表一位**</h3><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702230925118.png" alt="image-20200702230925118"></p><p><strong>三个【】代表三位也就是三个，例如123</strong></p><p><strong>匹配完毕就不会在回头看了</strong></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702231212386.png" alt="image-20200702231212386"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702231239057.png" alt="image-20200702231239057"></p><h3 id="表示非"><a href="#表示非" class="headerlink" title="[^]:表示非"></a><strong>[^]:表示非</strong></h3><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702232042530.png" alt="image-20200702232042530"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702232059838.png" alt="image-20200702232059838"></p><h3 id="表示或"><a href="#表示或" class="headerlink" title="|:表示或"></a><strong>|:表示或</strong></h3><h3 id=""><a href="#" class="headerlink" title=""></a><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702232349502.png" alt="image-20200702232349502"></h3><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702232236671.png" alt="image-20200702232236671"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702232534277.png" alt="image-20200702232534277"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702232614160.png" alt="image-20200702232614160"></p><h2 id="6-元字符"><a href="#6-元字符" class="headerlink" title="6.元字符"></a>6.元字符</h2><h3 id="1-表示查找单个字符，除了换行和行结束符"><a href="#1-表示查找单个字符，除了换行和行结束符" class="headerlink" title="1. .  表示查找单个字符，除了换行和行结束符"></a>1. .  表示查找单个字符，除了换行和行结束符</h3><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200703000147439.png" alt="image-20200703000147439"></p><p>•‘.’会匹配字符串中除了换行符\n之外的所有字符</p><p>例：</p><p>​         reg = /./; </p><p>​        str=’cainiao’;</p><p>​        execReg(reg,str); </p><p>结果显示，正则匹配到了字符c。</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702233537022.png" alt="image-20200702233537022"></p><h3 id="2-w与-W-前者表示0-9A-z-，后者是非前者"><a href="#2-w与-W-前者表示0-9A-z-，后者是非前者" class="headerlink" title="2.\w与\W:前者表示0-9A-z_，后者是非前者"></a>2.\w与\W:前者表示0-9A-z_，后者是非前者</h3><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702233727000.png" alt="image-20200702233727000"></p><h3 id="3-d与-D-表示数字【0-9】和非数字"><a href="#3-d与-D-表示数字【0-9】和非数字" class="headerlink" title="3.\d与\D:表示数字【0-9】和非数字"></a>3.\d与\D:表示数字【0-9】和非数字</h3><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702234157890.png" alt="image-20200702234157890"></p><h3 id="4-s与-S-表示空白字符和非空白字符"><a href="#4-s与-S-表示空白字符和非空白字符" class="headerlink" title="4.\s与\S:表示空白字符和非空白字符"></a>4.\s与\S:表示空白字符和非空白字符</h3><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702234550127.png" alt="image-20200702234550127"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702234643689.png" alt="image-20200702234643689"></p><h3 id="5-b与-B表示单词边界与非单词边界"><a href="#5-b与-B表示单词边界与非单词边界" class="headerlink" title="5.\b与\B表示单词边界与非单词边界"></a>5.\b与\B表示单词边界与非单词边界</h3><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702234846832.png" alt="image-20200702234846832"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702235135721.png" alt="image-20200702235135721"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702235234807.png" alt="image-20200702235234807"></p><p><strong>上式匹配出cde，因为c是单词边界，需要加上\b</strong></p><h3 id="6-t表示制表符"><a href="#6-t表示制表符" class="headerlink" title="6.\t表示制表符"></a>6.\t表示制表符</h3><p><strong>匹配成功</strong>（中间需要用\t,而不是键盘敲出tab键）</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702235539409.png" alt="image-20200702235539409"></p><p><strong>匹配失败</strong></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702235726067.png" alt="image-20200702235726067"></p><h3 id="7-unicode编码可以匹配汉字"><a href="#7-unicode编码可以匹配汉字" class="headerlink" title="7.unicode编码可以匹配汉字"></a>7.unicode编码可以匹配汉字</h3><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200703000040690.png" alt="image-20200703000040690"></p><h2 id="7-量词"><a href="#7-量词" class="headerlink" title="7.量词"></a>7.量词</h2><h3 id="1-c-n"><a href="#1-c-n" class="headerlink" title="1.c{n}"></a><strong>1.c{n}</strong></h3><p>{1}表示一个的意思。</p><p>/c{1}/只能匹配一个c。</p><p>/c{2}/则会匹配两个连续的c。</p><p>以此类推</p><p>/c{n}/   ？</p><h3 id="2-c-m-n"><a href="#2-c-m-n" class="headerlink" title="2.c{m,n}"></a><strong>2.c{m,n}</strong></h3><p>表示m个到n个c，且m小于等于n 。</p><h2 id="8-案例"><a href="#8-案例" class="headerlink" title="8.案例"></a>8.案例</h2><h3 id="1-匹配2-6个中文字符"><a href="#1-匹配2-6个中文字符" class="headerlink" title="1.匹配2-6个中文字符"></a>1.匹配2-6个中文字符</h3><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200703092930509.png" alt="image-20200703092930509"></p><h3 id="2-匹配邮箱"><a href="#2-匹配邮箱" class="headerlink" title="2.匹配邮箱"></a>2.匹配邮箱</h3><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200703095232525.png" alt="image-20200703095232525"></p><h3 id="3-验证密码强度"><a href="#3-验证密码强度" class="headerlink" title="3.验证密码强度"></a>3.验证密码强度</h3><p><strong>css部分</strong></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200703104120626.png" alt="image-20200703104120626"></p><p><strong>html部分</strong></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200703104229874.png" alt="image-20200703104229874"></p><p><strong>js部分</strong></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200703104045483.png" alt="image-20200703104045483"></p><p>​    </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>深拷贝</title>
      <link href="/2020/07/22/%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
      <url>/2020/07/22/%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>//创建一个对象<br>            var obj1 = {<br>                age:10,<br>                sex:”女”,<br>                car:[“法拉利”,”布加迪威龙”,”玛莎拉蒂”],//数组<br>                dog:{//对象属性<br>                    name:”贝贝”,<br>                    age:8,<br>                    color:”棕色”<br>                }<br>            };<br>            //创建另外一个对象<br>            var obj2 = {};//空对象<br>            /<em>console.log(obj2);</em>/</p><pre><code>//封装一个拷贝逻辑的函数,把对象a中的数据复制到对象b中function extend(a,b){    for(var key in a){//从a对象中复制        //1.获取到a对象中所有的属性的值        var item = a[key];//item是一个数组,封装了普通属性,数组,对象        //2.判断这个属性的值是不是数组-是数组就要遍历        if(item instanceof Array){//过滤是否是数组            //在对象b中开辟一个空间 - 数组            b[key] = [];//空数组            //调用这个函数,把a对象中的数组的属性一个个复制到b对象的数组中            extend(item,b[key]);//item封装的是数组        }else if(item instanceof Object){//如果是对象            //在b对象中创建一个对象 - 空的            b[key] = {};//空对象            //调用这个函数,把a对象中的对象的属性一个个复制到b对象的对象中            extend(item,b[key]);//item封装的是对象        }else{//普通属性            b[key] = item;//这一行是传复制对象与数组里面的值，也是递归的结束        }    }}//调用方法,实现深拷贝extend(obj1,obj2);console.dir(obj2);//原来是空对象console.dir(obj1);</code></pre><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><pre><code>//演示浅拷贝        //对象        var obj1 = {            age:10,            sex:&quot;男&quot;,            car:[&quot;三轮车&quot;,&quot;黄包车&quot;,&quot;摩托车&quot;]        };        //设置一个空对象 - 对象是存在的,但是没有内容        var obj2 = {};        //console.log(obj2);        //封装一个函数,作用是把一个对象中的属性复制给另一个对象 - 浅拷贝        function extend(a,b){//把a对象中所有的属性复制给b对象            //利用for循环处理 - 没有下标 - for-in            for(var key in a){                b[key] = a[key];            }        }        //调用这个函数,实现浅拷贝        extend(obj1,obj2);        console.log(obj2);        console.log(obj1);</code></pre><h2 id="遍历dom树"><a href="#遍历dom树" class="headerlink" title="遍历dom树"></a>遍历dom树</h2><p><strong>html部分</strong></p><pre><code>&lt;h1&gt;遍历DOM树&lt;/h1&gt;    &lt;p style=&quot;color:green;&quot;&gt;Tip:可以在遍历的回调函数中任意的定制需求&lt;/p&gt;    &lt;div&gt;        &lt;ul&gt;            &lt;li&gt;123&lt;/li&gt;            &lt;li&gt;456&lt;/li&gt;            &lt;li&gt;789&lt;/li&gt;        &lt;/ul&gt;        &lt;div&gt;            &lt;div&gt;                &lt;span&gt;哈啊哈哈哈哈哈&lt;/span&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;    &lt;div id=&quot;demo_node&quot;&gt;        &lt;ul&gt;            &lt;li&gt;123&lt;/li&gt;        &lt;/ul&gt;        &lt;p&gt;hello&lt;/p&gt;        &lt;h2&gt;world&lt;/h2&gt;        &lt;div&gt;            &lt;p&gt;asdfg&lt;/p&gt;            &lt;h3&gt;                &lt;span&gt;jfkldsaufoiasdj&lt;/span&gt;            &lt;/h3&gt;        &lt;/div&gt;    &lt;/div&gt;//1.获取页面中的根节点        var root = document.documentElement;//html        //函数遍历DOM        //根据根节点,调用fn函数,显示根节点的名字        function forDOM(root1){//传入一个形参            //获取根节点中给所有的子节点            var children = root1.children;            //遍历所有的子节点            forChildren(children);        }        //封装一个函数:给我所有的子节点,把这个子节点中的所有的子节点显示出来        function forChildren(children){            //遍历所有的子节点            for(var i=0;i&lt;children.length;i++){                //获取到每一个子节点                var child = children[i];                //显示每一个子节点的名字                f1(child);                //判断child下还有没有子节点,如果有,则继续遍历                child.children&amp;&amp;forDOM(child);            }        }        //调用函数,传入根节点        forDOM(root);        //显示节点的名字        function f1(node){            console.log(&quot;节点的名字: &quot; + node.nodeName);        }</code></pre><p>​<br>​            </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>函数作为函数的参数来传递的问题的小总结</title>
      <link href="/2020/07/22/%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E6%9D%A5%E4%BC%A0%E9%80%92%E7%9A%84%E9%97%AE%E9%A2%98%E7%9A%84%E5%B0%8F%E6%80%BB%E7%BB%93/"/>
      <url>/2020/07/22/%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E6%9D%A5%E4%BC%A0%E9%80%92%E7%9A%84%E9%97%AE%E9%A2%98%E7%9A%84%E5%B0%8F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="函数作为函数的参数来传递的问题的小总结"><a href="#函数作为函数的参数来传递的问题的小总结" class="headerlink" title="函数作为函数的参数来传递的问题的小总结"></a>函数作为函数的参数来传递的问题的小总结</h2><h2 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h2><h3 id="最简单的形式无参函数，直接形式函数的函数名放到括号中，再在执行部分这个函数即可。"><a href="#最简单的形式无参函数，直接形式函数的函数名放到括号中，再在执行部分这个函数即可。" class="headerlink" title="最简单的形式无参函数，直接形式函数的函数名放到括号中，再在执行部分这个函数即可。"></a>最简单的形式无参函数，直接形式函数的函数名放到括号中，再在执行部分这个函数即可。</h3><p>//当然调用时要穿另一个真正的定义好的函数<br>/*<br>function test1(Func)<br>{<br>Func();<br>}<br>function test2()<br>{<br>alert(“我是test2”);<br>}<br>test1(test2);<br>*/</p><h2 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h2><h3 id="带参数的普通调用法。跟第一种唯一的区别就是在定义主函数的执行语句里调用参数函数时该把参数加上"><a href="#带参数的普通调用法。跟第一种唯一的区别就是在定义主函数的执行语句里调用参数函数时该把参数加上" class="headerlink" title="带参数的普通调用法。跟第一种唯一的区别就是在定义主函数的执行语句里调用参数函数时该把参数加上"></a>带参数的普通调用法。跟第一种唯一的区别就是在定义主函数的执行语句里调用参数函数时该把参数加上</h3><p>/*<br>function test1(Func)<br>{<br>Func(mydata);<br>}<br>function test3(data)<br>{<br>alert(data);<br>}</p><p>test1(test3(“zhangran”));<br>*/</p><h2 id="第三种"><a href="#第三种" class="headerlink" title="第三种"></a>第三种</h2><h2 id="把第二种的引用的函数不在单独定义而是作为调用主函数时，里面的参数时生成，这里是个匿名的函数"><a href="#把第二种的引用的函数不在单独定义而是作为调用主函数时，里面的参数时生成，这里是个匿名的函数" class="headerlink" title="把第二种的引用的函数不在单独定义而是作为调用主函数时，里面的参数时生成，这里是个匿名的函数"></a>把第二种的引用的函数不在单独定义而是作为调用主函数时，里面的参数时生成，这里是个匿名的函数</h2><p>function test1(Func)<br>{<br>Func(“hello”);<br>}</p><p>test1(function(data)<br>{<br>alert(data);<br>});</p><h2 id="案列"><a href="#案列" class="headerlink" title="案列"></a>案列</h2><p>一个例子，我们想在页面中创建100个div节点，这是一种写法。我们发现并不是所有用户都是想把这100个div显示的的。所以就有第二种写法</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200701162849012.png" alt="image-20200701162849012"></p><p>　　</p><p><strong>第二种写法</strong></p><p>这是我们appendDiv传入了一个函数</p><p>​       function(node){</p><p>  node.style.display=’none’;</p><p>  }</p><p>　　</p><p>然后在appendDiv中判断这个是否是function，如果是我们就执行他，把它传入appendDiv()中</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200701163033131.png" alt="image-20200701163033131"></p><p>结论：</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200701163203710.png" alt="image-20200701163203710"></p><h2 id="函数作为参数"><a href="#函数作为参数" class="headerlink" title="函数作为参数"></a>函数作为参数</h2><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200701164406754.png" alt="image-20200701164406754"></p><h2 id="模拟函数作为参数使用的案例"><a href="#模拟函数作为参数使用的案例" class="headerlink" title="模拟函数作为参数使用的案例"></a>模拟函数作为参数使用的案例</h2><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200701164514801.png" alt="image-20200701164514801"></p><h2 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h2><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5C86133%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200701164640283.png" alt="image-20200701164640283"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>高阶函数最实用的几个高阶函数用法</title>
      <link href="/2020/07/22/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E6%9C%80%E5%AE%9E%E7%94%A8%E7%9A%84%E5%87%A0%E4%B8%AA%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95/"/>
      <url>/2020/07/22/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E6%9C%80%E5%AE%9E%E7%94%A8%E7%9A%84%E5%87%A0%E4%B8%AA%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="高阶函数不会用-教你JS中最实用的几个高阶函数用法"><a href="#高阶函数不会用-教你JS中最实用的几个高阶函数用法" class="headerlink" title="高阶函数不会用?教你JS中最实用的几个高阶函数用法"></a>高阶函数不会用?教你JS中最实用的几个高阶函数用法</h2><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><ul><li>函数可以作为参数传递</li><li>函数可以作为返回值输出</li></ul><h3 id="函数作为参数传递"><a href="#函数作为参数传递" class="headerlink" title="函数作为参数传递"></a>函数作为参数传递</h3><ul><li><p>回调函数</p></li><li><ul><li>在ajax异步请求的过程中，回调函数使用的非常频繁</li><li>在不确定请求返回的时间时，将callback回调函数当成参数传入</li><li>待请求完成后执行callback函数</li></ul></li></ul><p>下面看个简单的<strong>demo</strong>：</p><p>说实在的本来只是个简单的🌰，不过越写越兴奋，就弄成了个小demo了，大家也可以copy下去自己添油加醋一下(写成各种版本)，乐呵一下吧，PS:由于代码过多占用文章，将css样式去掉了，样式的实现大家随意发挥就好了</p><ul><li>html结构</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;&lt;div id&#x3D;&quot;box&quot;class&#x3D;&quot;clearfix&quot;&gt;&lt;&#x2F;div&gt;&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;jquery&#x2F;1.12.4&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script src&#x3D;&quot;.&#x2F;index.js&quot;&gt;&lt;&#x2F;script&gt;&lt;&#x2F;body</span><br></pre></td></tr></table></figure><p>js部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; index.js&#x2F;&#x2F; 回调函数&#x2F;&#x2F; 异步请求let getInfo &#x3D; function(keywords, callback) &#123;    $.ajax(&#123;        url: &#39;http:&#x2F;&#x2F;musicapi.leanapp.cn&#x2F;search&#39;,  &#x2F;&#x2F; 以网易云音乐为例        data: &#123;            keywords&#125;,        success: function(res) &#123;            callback &amp;&amp; callback(res.result.songs);&#125;&#125;)&#125;;</span><br><span class="line">$(&#39;#btn&#39;).on(&#39;click&#39;, function() &#123;    let keywords &#x3D; $(this).prev().val();    $(&#39;#loading&#39;).show();    getInfo(keywords, getData);&#125;);&#x2F;&#x2F; 加入回车$(&quot;#search_inp&quot;).on(&#39;keyup&#39;, function(e)&#123;if(e.keyCode &#x3D;&#x3D;&#x3D; 13) &#123;        $(&#39;#loading&#39;).show();        getInfo(this.value, getData);&#125;&#125;);</span><br><span class="line">function getData(data) &#123;if(data &amp;&amp; data.length) &#123;        let html &#x3D; render(data);&#x2F;&#x2F; 初始化Dom结构        initDom(html, function(wrap) &#123;            play(wrap);&#125;);&#125;&#125;&#x2F;&#x2F; 格式化时间戳function formatDuration(duration) &#123;    duration &#x3D; parseInt(duration &#x2F; 1000);     &#x2F;&#x2F; 转换成秒    let hour &#x3D; Math.floor(duration &#x2F; 60&#x2F; 60),        min &#x3D; Math.floor((duration % 3600) &#x2F; 60),        sec &#x3D; duration % 60,        result &#x3D; &#39;&#39;;</span><br><span class="line">    result +&#x3D; &#96;$&#123;fillIn(min)&#125;:$&#123;fillIn(sec)&#125;&#96;;return result;&#125;</span><br><span class="line">function fillIn(n) &#123;return n &lt; 10? &#39;0&#39;+ n : &#39;&#39;+ n;&#125;</span><br><span class="line">let initDom &#x3D; function(tmp, callback) &#123;    $(&#39;.item&#39;).remove();    $(&#39;#loading&#39;).hide();    $(&#39;#box&#39;).append(tmp);&#x2F;&#x2F; 这里因为不知道dom合适才会被完全插入到页面中&#x2F;&#x2F; 所以用callback当参数，等dom插入后再执行callback    callback &amp;&amp; callback(box);&#125;;</span><br><span class="line">let render &#x3D; function(data) &#123;    let template &#x3D; &#39;&#39;;    let set&#x3D; newSet(data);    data &#x3D; [...set];    &#x2F;&#x2F; 可以利用Set去做下简单的去重，可忽略这步for(let i &#x3D; 0; i &lt; 8; i++) &#123;        let item &#x3D; data[i];        let name &#x3D; item.name;        let singer &#x3D; item.artists[0].name;        let pic &#x3D; item.album.picUrl;        let time &#x3D; formatDuration(item.duration);</span><br><span class="line">        template +&#x3D; &#96;&lt;div class&#x3D;&quot;item&quot;&gt;&lt;div class&#x3D;&quot;pic&quot; data-time&#x3D;&quot;$&#123;time&#125;&quot;&gt;&lt;span&gt;&lt;&#x2F;span&gt;&lt;img src&#x3D;&quot;$&#123;pic&#125;&quot;&#x2F;&gt;&lt;&#x2F;div&gt;&lt;h4&gt;$&#123;name&#125;&lt;&#x2F;h4&gt;&lt;p&gt;$&#123;singer&#125;&lt;&#x2F;p&gt;&lt;audio src&#x3D;&quot;http:&#x2F;&#x2F;music.163.com&#x2F;song&#x2F;media&#x2F;outer&#x2F;url?id&#x3D;$&#123;item.id&#125;.mp3&quot;&gt;&lt;&#x2F;audio&gt;&lt;&#x2F;div&gt;&#96;;&#125;return template;&#125;;</span><br><span class="line">let play &#x3D; function(wrap) &#123;    wrap &#x3D; $(wrap);    wrap.on(&#39;click&#39;, &#39;.item&#39;, function() &#123;        let self &#x3D; $(this),            $audio &#x3D; self.find(&#39;audio&#39;),            $allAudio &#x3D; wrap.find(&#39;audio&#39;);</span><br><span class="line">for(let i &#x3D; 0; i &lt; $allAudio.length; i++) &#123;            $allAudio[i].pause();&#125;        $audio[0].play();        self.addClass(&#39;play&#39;).siblings(&#39;.item&#39;).removeClass(&#39;play&#39;);&#125;);&#125;;</span><br></pre></td></tr></table></figure><p>按照上面的代码啪啪啪，就会得到下面这样的效果，一起来看下吧</p><p><img src= "/img/loading.gif" data-src="https://mmbiz.qpic.cn/mmbiz_gif/XP4dRIhZqqUx3VRzZ8wsXPrakS6axgoqy0cPzA7F13UGcpxhdO1olThvYEIjXxoubrNtBMNWPBKI8jmR7FC7LA/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="img"></p><p>不过依然感谢网易云音乐提供的API接口，让我们聆听美妙好音乐</p><ul><li>好了回归主旋律，前面的戏份有点过了，不知不觉居然写了个小demo，确实有点过分了</li><li>本来是说一下<strong>函数作为参数传递</strong>的应用，写的太多了，赶紧调转船头继续讲吧</li></ul><h3 id="函数作为返回值输出"><a href="#函数作为返回值输出" class="headerlink" title="函数作为返回值输出"></a>函数作为返回值输出</h3><p>亲们，函数作为返回值输出的应用场景那就太多了，这也体现了函数式编程的思想。其实从闭包的例子中我们就已经看到了关于高阶函数的相关内容了，哈哈</p><p>还记得在我们去判断数据类型的时候，我们都是通过<strong>Object.prototype.toString</strong>来计算的。每个数据类型之间只是’[object XXX]’不一样罢了</p><p>所以在我们写类型判断的时候，一般都是将参数传入函数中，这里我简单写一下实现，咱们先来看看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function isType(type) &#123;return function(obj) &#123;returnObject.prototype.toString.call(obj) &#x3D;&#x3D;&#x3D; &#96;[object $&#123;type&#125;]&#125;&#125;</span><br><span class="line">const isArray &#x3D; isType(&#39;Array&#39;);const isString &#x3D; isType(&#39;String&#39;);console.log(isArray([1, 2, [3,4]]); &#x2F;&#x2F; trueconsole.log(isString(&#123;&#125;);           &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure><p>其实上面实现的isType函数，也属于<strong>偏函数</strong>的范畴，偏函数实际上是返回了一个包含<strong>预处理参数</strong>的新函数，以便之后可以调用</p><p>另外还有一种叫做预置函数，它的实现原理也很简单，当达到条件时再执行回调函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function after(time, cb) &#123;return function() &#123;if(--time &#x3D;&#x3D;&#x3D; 0) &#123;            cb();&#125;&#125;&#125;&#x2F;&#x2F; 举个栗子吧，吃饭的时候，我很能吃，吃了三碗才能吃饱let eat &#x3D; after(3, function() &#123;    console.log(&#39;吃饱了&#39;);&#125;);eat();eat();eat();</span><br></pre></td></tr></table></figure><p>上面的eat函数只有执行3次的时候才会输出’吃饱了’，还是比较形象的。</p><p>这种预置函数也是js中巧妙的装饰者模式的实现，装饰者模式在实际开发中也非常有用，再以后的岁月里我也会好好研究之后分享给大家的</p><p>好了，不要停，不要停，再来看一个栗子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 这里我们创建了一个单例模式let single &#x3D; function(fn) &#123;        let ret;return function() &#123;            console.log(ret);   &#x2F;&#x2F; render一次undefined,render二次true,render三次true&#x2F;&#x2F; 所以之后每次都执行ret，就不会再次绑定了return ret || (ret &#x3D; fn.apply(this, arguments));&#125;&#125;;</span><br><span class="line">    let bindEvent &#x3D; single(function() &#123;&#x2F;&#x2F; 虽然下面的renders函数执行3次，bindEvent也执行了3次&#x2F;&#x2F; 但是根据单例模式的特点，函数在被第一次调用后，之后就不再调用了        document.getElementById(&#39;box&#39;).onclick &#x3D; function() &#123;            alert(&#39;click&#39;);&#125;return true;&#125;);</span><br><span class="line">    let renders &#x3D; function() &#123;        console.log(&#39;渲染&#39;);        bindEvent();&#125;</span><br><span class="line">    renders();    renders();    renders();</span><br></pre></td></tr></table></figure><p>这个高阶函数的栗子，可以说一石二鸟啊，既把函数当做参数传递了，又把函数当返回值输出了。</p><p>单例模式也是一种非常实用的设计模式，在以后的文章中也会针对这些设计模式去分析的，敬请期待，哈哈，下面再看看高阶函数还有哪些用途</p><h3 id="其他应用"><a href="#其他应用" class="headerlink" title="其他应用"></a>其他应用</h3><h4 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h4><p>柯里化又称部分求值，柯里化函数会接收一些参数，然后不会立即求值，而是继续返回一个新函数，将传入的参数通过闭包的形式保存，等到被真正求值的时候，再一次性把所有传入的参数进行求值</p><p>还能阐述的更简单吗？在一个函数中填充几个参数，然后再返回一个新函数，最后进行求值，没了，是不是说的简单了</p><p>说的再简单都不如几行代码演示的清楚明白</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 普通函数function add(x,y)&#123;return x + y;&#125;</span><br><span class="line">add(3,4);   &#x2F;&#x2F; 7</span><br><span class="line">&#x2F;&#x2F; 实现了柯里化的函数&#x2F;&#x2F; 接收参数，返回新函数，把参数传给新函数使用，最后求值let add &#x3D; function(x)&#123;return function(y)&#123;return x + y;&#125;&#125;;</span><br><span class="line">add(3)(4);  &#x2F;&#x2F; 7</span><br></pre></td></tr></table></figure><p>以上代码非常简单，只是起个引导的作用。下面我们来写一个通用的柯里化函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function curry(fn) &#123;    let slice &#x3D; Array.prototype.slice,  &#x2F;&#x2F; 将slice缓存起来        args &#x3D; slice.call(arguments, 1);   &#x2F;&#x2F; 这里将arguments转成数组并保存</span><br><span class="line">return function() &#123;&#x2F;&#x2F; 将新旧的参数拼接起来        let newArgs &#x3D; args.concat(slice.call(arguments));return fn.apply(null, newArgs); &#x2F;&#x2F; 返回执行的fn并传递最新的参数&#125;&#125;</span><br></pre></td></tr></table></figure><p>实现了通用的柯里化函数，了不起啊，各位很了不起啊。</p><p>不过这还不够，我们还可以利用ES6再来实现一下，请看如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; ES6版的柯里化函数function curry(fn) &#123;const g &#x3D; (...allArgs) &#x3D;&gt; allArgs.length &gt;&#x3D; fn.length ?        fn(...allArgs) :(...args) &#x3D;&gt; g(...allArgs, ...args)</span><br><span class="line">return g;&#125;</span><br><span class="line">&#x2F;&#x2F; 测试用例const foo &#x3D; curry((a, b, c, d) &#x3D;&gt; &#123;    console.log(a, b, c, d);&#125;);foo(1)(2)(3)(4);    &#x2F;&#x2F; 1 2 3 4const f &#x3D; foo(1)(2)(3);f(5);               &#x2F;&#x2F; 1 2 3 5</span><br></pre></td></tr></table></figure><p>两种不同的实现思路相同，之后可以试着分析一下</p><p>不过大家有没有发现我们在ES5中使用的bind方法，其实也利用了柯里化的思想，那么再来看一下下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let obj &#x3D; &#123;    songs: &#39;以父之名&#39;&#125;;</span><br><span class="line">function fn() &#123;    console.log(this.songs);&#125;</span><br><span class="line">let songs &#x3D; fn.bind(obj);songs();   &#x2F;&#x2F; &#39;以父之名&#39;</span><br></pre></td></tr></table></figure><p>为什么这么说？这也看不出什么头绪啊，别捉急，再来看一下bind的实现原理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind &#x3D; function(context) &#123;    let self &#x3D; this,        slice &#x3D; Array.prototype.slice,        args &#x3D; slice.call(arguments);</span><br><span class="line">return function() &#123;return self.apply(context, args.slice(1));&#125;&#125;;</span><br></pre></td></tr></table></figure><p>是不是似曾相识，是不是，是不是，有种师出同门的赶脚了啊</p><h4 id="反柯里化"><a href="#反柯里化" class="headerlink" title="反柯里化"></a>反柯里化</h4><p>啥？反柯里化，刚刚被柯里化弄的手舞足蹈的，现在又出现了个反柯里化，有木有搞错啊！那么反柯里化是什么呢？简而言之就是函数的借用，天下函数(方法)大家用</p><p>比如，一个对象未必只能使用它自身的方法，也可以去借用原本不属于它的方法，要实现这点似乎就很简单了，因为call和apply就可以完成这个任务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(function() &#123;&#x2F;&#x2F; arguments就借用了数组的push方法    let result &#x3D; Array.prototype.slice.call(arguments);    console.log(result);     &#x2F;&#x2F; [1, 2, 3, &#39;hi&#39;]&#125;)(1, 2, 3, &#39;hi&#39;);</span><br><span class="line">Math.max.apply(null, [1,5,10]);  &#x2F;&#x2F; 数组借用了Math.max方法</span><br></pre></td></tr></table></figure><p>从以上代码中看出来了，大家都是相亲相爱的一家人。利用call和apply改变了this指向，方法中用到的this再也不局限在原来指定的对象上了，加以泛化后得到更广的适用性</p><p>反柯里化的话题是由我们亲爱的js之父发表的，我们来从实际例子中去看一下它的作用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let slice &#x3D; Array.prototype.slice.uncurrying();</span><br><span class="line">(function() &#123;    let result &#x3D; slice(arguments);  &#x2F;&#x2F; 这里只需要调用slice函数即可    console.log(result);    &#x2F;&#x2F; [1, 2, 3]&#125;)(1,2,3);</span><br></pre></td></tr></table></figure><p>以上代码通过反柯里化的方式，把Array.prototype.slice变成了一个通用的slice函数，这样就不会局限于仅对数组进行操作了，也从而将函数调用显得更为简洁清晰了</p><p>最后再来看一下它的实现方式吧，看代码，更逼真</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.uncurrying &#x3D; function() &#123;    let self &#x3D; this;    &#x2F;&#x2F; self 此时就是下面的Array.prototype.push方法returnfunction() &#123;        let obj &#x3D; Array.prototype.shift.call(arguments);&#x2F;*            obj其实是这种样子的            obj &#x3D; &#123;                &#39;length&#39;: 1,                &#39;0&#39;: 1            &#125;        *&#x2F;return self.apply(obj, arguments); &#x2F;&#x2F; 相当于Array.prototype.push(obj, 110)&#125;&#125;;let slice &#x3D; Array.prototype.push.uncurrying();</span><br><span class="line">let obj &#x3D; &#123;&#39;length&#39;: 1,&#39;0&#39;: 1&#125;;push(obj, 110);console.log(obj);   &#x2F;&#x2F; &#123; &#39;0&#39;: 1, &#39;1&#39;: 110, length: 2 &#125;</span><br></pre></td></tr></table></figure><p>其实实现反柯里化的方式不只一种，下面再给大家分享一种，直接看代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.uncurrying &#x3D; function() &#123;    let self &#x3D; this;return function() &#123;return Function.prototype.call.apply(self, arguments);&#125;&#125;;</span><br></pre></td></tr></table></figure><p>实现方式大致相同，大家也可以写一下试试，动动手，活动一下筋骨</p><h4 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h4><p>下面再说一下函数节流，我们都知道在onresize、onscroll和mousemove，上传文件这样的场景下，函数会被频繁的触发，这样很消耗性能，浏览器也会吃不消的</p><p>于是大家开始研究一种高级的方法，那就是控制函数被触发的频率，也就是函数节流了。简单说一下原理，利用setTimeout在一定的时间内，函数只触发一次，这样大大降低了频率问题</p><p>函数节流的实现也多种多样，这里我们实现大家常用的吧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function throttle (fn, wait) &#123;    let _fn &#x3D; fn,       &#x2F;&#x2F; 保存需要被延迟的函数引用        timer,        flags &#x3D; true;   &#x2F;&#x2F; 是否首次调用</span><br><span class="line">return function() &#123;        let args &#x3D; arguments,            self &#x3D; this;</span><br><span class="line">if(flags) &#123;    &#x2F;&#x2F; 如果是第一次调用不用延迟，直接执行即可            _fn.apply(self, args);            flags &#x3D; false;return flags;&#125;&#x2F;&#x2F; 如果定时器还在，说明上一次还没执行完，不往下执行if(timer) returnfalse;</span><br><span class="line">        timer &#x3D; setTimeout(function() &#123; &#x2F;&#x2F; 延迟执行            clearTimeout(timer);    &#x2F;&#x2F; 清空上次的定时器            timer &#x3D; null;           &#x2F;&#x2F; 销毁变量            _fn.apply(self, args);&#125;, wait);&#125;&#125;</span><br><span class="line">window.onscroll &#x3D; throttle(function() &#123;    console.log(&#39;滚动&#39;);&#125;, 500);</span><br></pre></td></tr></table></figure><p>给页面上body设置一个高度出现滚动条后试试看，比每滚动一下就触发来说，大大降低了性能的损耗，这就是函数节流的作用，起到了事半功倍的效果，开发中也比较常用的</p><h4 id="分时函数"><a href="#分时函数" class="headerlink" title="分时函数"></a>分时函数</h4><p>我们知道有一个典故叫做：罗马不是一天建成的；更为通俗的来说，胖纸也不是一天吃成的</p><p>体现在程序里也是一样，我们如果一次获得了很多数据(比如有10W数据)，然后在前端渲染的时候会卡到爆，浏览器那么温柔的物种都会起来骂娘了</p><p>所以在处理这么多数据的时候，我们可以选择分批进行，不用一次塞辣么多，嘴就辣么大</p><p>下面来看一下简单的实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function timeChunk(data, fn, count &#x3D; 1, wait) &#123;    let obj, timer;</span><br><span class="line">function start() &#123;        let len &#x3D; Math.min(count, data.length);for(let i &#x3D; 0; i &lt; len; i++) &#123;            val &#x3D; data.shift();     &#x2F;&#x2F; 每次取出一个数据，传给fn当做值来用            fn(val);&#125;&#125;</span><br><span class="line">return function() &#123;        timer &#x3D; setInterval(function() &#123;if(data.length &#x3D;&#x3D;&#x3D; 0) &#123;    &#x2F;&#x2F; 如果数据为空了，就清空定时器return clearInterval(timer);&#125;            start();&#125;, wait);   &#x2F;&#x2F; 分批执行的时间间隔&#125;&#125;</span><br><span class="line">&#x2F;&#x2F; 测试用例let arr &#x3D; [];for(let i &#x3D; 0; i &lt; 100000; i++) &#123;  &#x2F;&#x2F; 这里跑了10万数据    arr.push(i);&#125;let render &#x3D; timeChunk(arr, function(n) &#123;   &#x2F;&#x2F; n为data.shift()取到的数据    let div &#x3D; document.createElement(&#39;div&#39;);    div.innerHTML &#x3D; n;    document.body.appendChild(div);&#125;, 8, 20);</span><br><span class="line">render();</span><br></pre></td></tr></table></figure><h4 id="惰性加载"><a href="#惰性加载" class="headerlink" title="惰性加载"></a>惰性加载</h4><p>兼容现代浏览器以及IE浏览器的事件添加方法就是一个很好的栗子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 常规的是这样写的let addEvent &#x3D; function(ele, type, fn) &#123;if(window.addEventListener) &#123;return ele.addEventListener(type, fn, false);&#125; elseif(window.attachEvent) &#123;return ele.attachEvent(&#39;on&#39;+ type, function() &#123;            fn.call(ele);&#125;);&#125;&#125;;</span><br></pre></td></tr></table></figure><p>这样实现有一个缺点，就是在调用addEvent的时候都会执行分支条件里，其实只需要判断一次就行了，非要每次执行都来一波</p><p>下面我们再来优化一下addEvent，以规避上面的缺点，就是我们要实现的惰性加载函数了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let addEvent &#x3D; function(ele, type, fn) &#123;if(window.addEventListener) &#123;        addEvent &#x3D; function(ele, type, fn) &#123;            ele.addEventListener(type, fn, false);&#125;&#125; elseif(window.attachEvent) &#123;        addEvent &#x3D; function(ele, type, fn) &#123;            ele.attachEvent(&#39;on&#39;+ type, function() &#123;                fn.call(ele)&#125;);&#125;&#125;</span><br><span class="line">    addEvent(ele, type, fn);&#125;;</span><br></pre></td></tr></table></figure><p>上面的addEvent函数还是个普通函数，还是有分支判断。不过当第一次进入分支条件后，在内部就会重写了addEvent函数</p><p>下次再进入addEvent函数的时候，函数里就不存在条件判断了</p><h2 id="终点"><a href="#终点" class="headerlink" title="终点"></a>终点</h2><p>节目不早，时间刚好，又到了该要说再见的时候了，来一个结束语吧</p><p><strong>高阶函数</strong></p><ul><li><p>可以把函数当做参数传递和返回值输出</p></li><li><p>函数柯里化</p></li><li><ul><li>接收参数，返回新函数，把参数传给新函数，最后求值</li></ul></li><li><ul><li>定义</li><li>作用</li></ul></li><li><ul><li>参数复用 (add函数栗子)</li><li>提前返回 (惰性加载)</li><li>延迟计算 (bind)</li></ul></li><li><p>反柯里化</p></li><li><ul><li>统一方法，让天下没有不能用的方法</li></ul></li><li><p>函数节流</p></li><li><ul><li>将频繁调用的函数设定在一个时间内执行，防止多次触发</li></ul></li><li><p>分时函数</p></li><li><ul><li>一次性加载太多太多数据，吃不消，可以像node中流一样，慢慢来，别急</li></ul></li><li><p>惰性加载</p></li><li><ul><li>函数执行的分支仅会发生一次</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
